# 인터럽트의 원리와 프로그램 실행


* [프로그램의 구조와 인터럽트](#프로그램의-구조와-인터럽트)
* [컴퓨터 시스템의 작동 개요](#컴퓨터-시스템의-작동-개요)
* [프로그램의 실행](#프로그램의-실행)
* [사용자 프로그램이 사용하는 함수](#사용자-프로그램이-사용하는-함수)
* [인터럽트](#인터럽트)
* [시스템 콜](#시스템-콜)


&nbsp;      
## 프로그램의 구조와 인터럽트
컴퓨터 프로그램의 내부적인 구조는 함수들로 구성된다.  하나의 함수가 수행되는 중에 다른 함수를 호출하고, 호출된 함수의 수행이 끝마쳐지면 다시 원래 호출했던 함수의 위치로 되돌아가 프로그램을 계속 수행하게 된다.


프로그램이 CPU에서 명령을 수행하려면 수행하려는 주소 영역이 메모리에 올라가 있어야 한다. 이때 프로그램의 주소 영역은 크게 코드, 데이터, 스택 영역으로 구분된다.
* 코드 영역은 우리가 작성한 프로그램 함수들의 코드가 기계어 명령(machine instruction)으로 변환되어 저장되는 부분이다.
* 데이터 영역은 전역 변수 등 프로그램이 사용하는 데이터를 저장하는 부분이다.
* 스택 영역은 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데에 사용되는 공간이다.


인터럽트의 동작 원리도 함수의 호출과 비슷하다. 일반적으로 프로그램 내에서 발생되는 함수 호출에 필요한 복귀 주소는 각 프로그램의 주소 공간 중 스택 영역에 보관한다. 반면, 인터럽트 때문에 CPU를 선점당한 위치를 저장하기 위한 공간은 운영 체제 커널 부분에 존재하게 된다.


운영 체제는 현재 실행 중인 모든 프로그램을 관리하기 위한 자료 구조 프로세스 제어 블록(PCB: Process Control Block)을 유지하고 있다. 프로세스 제어 블록에는 인터럽트가 발생했을 때 그 프로그램의 어느 부분까지 수행했는지를 저장하기 위한 영역이 존재한다.


&nbsp;      
## 컴퓨터 시스템의 작동 개요
CPU는 현재 수행해야 할 메모리 주소의 명령을 있는 그대로 처리하는데 이때, CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터를 프로그램 카운터라고 부른다. CPU는 매번 프로그램 카운터가 가리키는 메모리 영역의 명령을 처리하게 된다. 일반적으로 프로그램 카운터는 항상 바로 다음 주소의 명령을 가리키게 되어 코드의 순차적인 수행이 이루어진다.


컴퓨터 시스템을 구성하는 하드웨어로는 CPU와 메모리, 각 입출력 장치와 이들 장치를 전담하는 작은 CPU = 입출력 컨트롤러(I/O controller)와 메모리 = 로컬 버퍼(local buffer)가 있다.


메모리에는 사용자 프로그램들과 운영 체제가 같이 올라가 수행된다. 이때 CPU는 프로그램 카운터가 가리키는 메모리 위치의 프로그램을 수행하게 된다. 프로그램 카운터가 메모리 주소 중 운영체제가 존재하는 부분을 가리키고 있다면, CPU가 커널 모드(kernel mode)에서 수행 중이라고 이야기한다. 반대로 사용자 프로그램이 존재하는 메모리 위치를 가리킬 경우 사용자 모드(user mode)에서 CPU가 수행되고 있다고 이야기한다. 통상적으로 명령들은 순차적으로 수행되나, 함수 호출 등으로 점프해 바로 다음 주소가 아닌 명령을 수행할 수도 있다.


CPU가 수행하는 명령에는 일반 명령과 특권 명령이 있다. 일반 명령은 메모리에서 자료를 읽어와서 CPU에서 계산하고 결과를 메모리에 쓰는 일련의 명령으로 모든 프로그램이 수행할 수 있다. 특권 명령은 보안이 필요한 명령으로 입출력 장치, 타이머 등 각종 장치를 접근하는 명령이다. 운영 체제만이 수행할 수 있도록 제한하고 있다. 컴퓨터 시스템은 이 두 명령의 실행 가능성을 체크하기 위해 CPU 내에 모드 비트(mode bit)를 둔다.


사용자 프로그램이 실행되다 특권 명령의 수행이 필요한 경우 운영 체제에게 특권 명령의 대행을 요청하는데 이와 같은 서비스 요청을 시스템 콜(system call)이라고 부른다. 사용자 프로그램이 시스템 콜을 하게 되면 운영 체제는 사용자 프로그램의 코드가 아닌 자신의 커널 영역에 정의된 시스템 콜 처리 코드를 수행하게 된다.


주변 장치는 CPU의 도움이 필요한 경우 인터럽트를 사용해 CPU에게 서비스를 요청한다. 인터럽트를 발생 시키기 위해 주변 장치는 인터럽트 라인(interrupt line)을 세팅하게 되고 CPU는 매번 명령을 수행한 직후 인터럽트 라인을 체크해 서비스 요청이 들어왔는지를 체크하게 된다. 인터럽트가 발생하면 CPU는 해당 인터럽트를 처리하기 위한 루틴으로 넘어가서 커널 내의 인터럽트 처리 코드를 수행하게 된다.


&nbsp;      
## 프로그램의 실행
"프로그램이 실행(program execution) 되고 있다"라는 것은 컴퓨터 시스템 차원에서 볼 때 크게 두 가지 중요한 의미를 가진다. 첫째는 디스크에 존재하던 실행 파일이 메모리에 적재됨을 의미하고 두 번째는 프로그램이 CPU를 할당받고 기계 명령(instruction)을 수행하고 있는 상태를 의미한다.


여러 프로그램이 공유해서 사용하는 메모리 공간을 좀 더 효율적으로 사용하기 위해 프로그램의 주소 공간 중 당장 CPU의 수행에 필요한 부분은 메모리에 올려놓고 그렇지 않은 부분은 디스크 중 메모리의 연장 공간으로 사용되는 스왑 영역에 내려놓는 방식으로 운영된다.


프로세스의 주소 공간은 코드, 데이터, 스택 등으로 구성되는데 각각의 프로그램마다 이러한 주소 공간을 별도로 가지며, 각 프로그램마다 독자적으로 존재하는 이와 같은 주소 공간을 가상 메모리(virtual memory) 또는 논리적 메모리(logical memory)라고 부른다. 이는 실제 물리적 메모리의 주소와 독립적으로 각 프로그램마다 독자적인 주소 공간을 가지기 때문에 지칭하는 용어이다.


운영 체제 커널 역시 코드, 데이터, 스택의 주소 공간 구성을 가지고 있다. 


![커널 주소 공간의 내용](https://github.com/0jun0815/YJStudy/blob/master/운영체제/인터럽트의%20원리와%20프로그램%20실행/images/커널-주소-공간의-내용.png)


* 커널의 코드는 CPU, 메모리 등의 자원을 관리하기 위한 부분과 사용자에게 편리한 인터페이스를 제공하기 위한 부분, 시스템 콜 및 인터럽트를 처리하기 위한 부분을 포함한다.
* 커널의 데이터 영역에는 각종 자원을 관리하기 위한 자료 구조가 저장된다. 현재 수행 중인 프로그램을 프로세스(process)라 부르고, 커널의 데이터 영역 중에는 각 프로세스의 상태, CPU 사용 정보, 메모리 사용 정보 등을 유지하기 위한 자료 구조인 PCB(프로세스 제어 블록)을 두고 있다.
* 커널의 스택 영역은 일반 프로그램의 스택 영역과 마찬가지로 함수 호출시의 복귀 주소를 저장하기 위한 용도로 사용된다. 하지만 일반 사용자 프로그램의 스택과 달리 현재 수행 중인 프로세스마다 별도의 스택을 두어 관리한다. 프로그램이 실행되어 자기 자신의 코드 내에서 함수 호출 및 복귀 주소를 유지하기 위해서는 자기 주소 공간 내의 스택을 사용하고, 시스템 콜 등 커널 내의 함수를 호출하는 경우에는 커널의 주소 공간에 존재하는 커널 스택을 사용하게 된다.


&nbsp;      
## 사용자 프로그램이 사용하는 함수
프로그램이 사용하는 함수는 사용자 정의 함수, 라이브러리 함수, 커널 함수 세 가지로 구분할 수 있다.
* 사용자 정의 함수란 프로그래머가 직접 작성한 함수이고 라이브러리 함수란 프로그래머가 직접 작성하지는 않았지만 이미 누군가 작성해 놓은 함수를 호출만 하여 사용하는 경우를 뜻한다. 
    * 이 두 함수는 프로그램이 실행될 때에 해당 프로세스의 주소 공간에 포함된다. 함수 호출시에도 자신의 주소 공간에 있는 스택을 사용하게 된다.
* 커널 함수는 운영 체제 커널의 코드에 정의된 함수로 종류에는 시스템콜 함수와 인터럽트 처리 함수가 있다.
    * 커널 함수는 사용자 프로그램의 주소 공간에 그 코드가 존재하는 것이 아니라 운영 체제 커널의 주소 공간에 코드가 정의된다. 즉, 운영 체제 내에 있는 함수를 사용자 프로그램이 호출해서 사용하는 것이다.


&nbsp;      
## 인터럽트
인터럽트는 하드웨어 인터럽트와 소프트웨어 인터럽트로 나뉘며 하드웨어 컨트롤러가 CPU의 서비스를 요청하기 위해 발생 시키는 인터럽트가 일반적인 의미의 인터럽트를 지칭한다.


CPU는 프로그램 카운터가 가리키는 곳에 있는 명령을 수행하는 일밖에 하지 않기 때문에 현재 수행 중인 프로세스로부터 CPU를 회수해 CPU가 다른 일을 수행하도록 하기 위해서는 인터럽트 메커니즘이 필요하다.
1. CPU 서비스를 요청해야 할 경우 CPU 내에 있는 인터럽트 라인을 세팅해 발생 시킨다.
2. CPU는 매번 프로그램 카운터가 가리키고 있는 지점의 명령을 하나씩 수행하고 나서 다음 명령을 수행하기 직전에 인터럽트 라인이 세팅되었는지를 체크한다.
3. 인터럽트가 발생했으면 CPU는 현재 수행하던 프로세스를 멈추고 운영 체제의 인터럽트 처리 루틴으로 이동해서 인터럽트 처리를 수행한다.
4. 특정 프로세스가 CPU를 독점하는 것을 막기 위해 운영 체제는 타이머 인터럽트를 사용한다. 타이머는 세팅된 시간이 되면 CPU에게 인터럽트를 발생 시키는 하드웨어 장치이다.
5. 타이머 인터럽트 때에 CPU를 그 프로세스로부터 회수해 다른 프로세스에게 이양한다.


넓은 의미의 인터럽트는 하드웨어 인터럽트와 트랩(trap)을 모두 포함하는 개념이다. 트랩의 종류에는 예외 상황(exception)과 시스템 콜(system call) 두 종류가 있다.
* 예외 상황은 프로그램이 허용되지 않는 연산을 수행하려고 할 때 자동적으로 발생하는 것으로 운영 체제는 예외 상황이 발생했을 때 CPU의 제어권을 획득해 해당 상황에 대한 조치를 취하게 된다.
    * 운영 체제는 예외 상황에 대한 처리 루틴을 인터럽트 처리 루틴과 마찬가지로 자신의 코드 영역에 가지고 있다.
* 시스템 콜은 사용자 프로세스가 운영 체제의 서비스(특권 명령)를 요청하기 위해 커널의 함수를 호출하는 것이다.
* 시스템 콜이나 예외 상황은 모두 사용자 프로세스로부터 CPU의 제어권이 운영 체제에게 이양되어 처리되는데 이 과정에 인터럽트 라인을 세팅하여 인터럽트를 발생 시킨 후 제어권이 넘어가게 되므로 이들도 넓은 의미에서는 인터럽트의 범주에 포함시킨다.


인터럽트와 관련된 주요 용어에는 인터럽트 벡터(interrupt vector)와 인터럽트 핸들러(interrupt handler)가 있다.
* 인터럽트 벡터란 여러 가지 인터럽트에 대해 해당 인터럽트 발생 시 처리해야 할 루틴의 주소를 보관하고 있는 테이블을 의미한다.
* 인터럽트 핸들러는 실제 인터럽트를 처리하기 위한 루틴으로 인터럽트 서비스 루틴이라고도 부른다.


인터럽트의 처리를 마치고 나면 인터럽트가 발생하기 직전의 프로세스에게 CPU의 제어권이 다시 넘어가게 된다. 다만, 타이머 인터럽트인 경우에는 CPU를 그 프로세스로부터 회수해 다른 프로세스에게 이양하기 위해 발생 시킨 인터럽트이므로 CPU의 제어권을 직전에 작업하던 프로세스에게 다시 부여하지 않는다.


&nbsp;      
## 시스템 콜
시스템 콜이란 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것.


컴퓨터 시스템에서는 하드웨어 및 소프트웨어 자원의 보안을 위해 CPU가 실행할 수 있는 명령을 일반 명령과 특권 명령으로 나누어 관리한다. 이러한 관리를 하드웨어적으로 지원하기 위해 모드 비트(mode bit)를 두고 0으로 세팅된 경우를 커널 모드, 1로 세팅된 경우를 사용자 모드라고 부른다.


CPU는 매 시점 명령을 수행하기 전에 현재 모드 비트를 체크해 커널 모드인 경우에만 특권 명령을 수행할 수 있도록 제한하고 있다.
* 운영 체제가 사용자 프로그램에게 CPU의 제어권을 넘길 때에는 모드 비트를 0에서 1로 바꾸어 사용자 프로그램이 특권 명령을 수행하는 것을 방지한다.
* 사용자 프로그램이 특권 명령을 수행할 필요가 있을 경우 운영 체제에게 시스템 콜(system call)을 통해 특권 명령의 대행을 요청하면 CPU의 제어권이 운영 체제로 넘어가고 모드 비트가 1에서 0으로 자동 세팅된다.


일반적인 함수 호출이 자신의 스택에 복귀 주소를 저장한 후 호출된 함수 위치로 점프하는 것임에 비해 시스템 콜은 주소 공간 자체가 다른 곳으로 이동해야 하므로 일반 함수 호출과는 상이한 방법을 사용한다. 그 방법은 프로그램 자신이 인터럽트 라인에 인터럽트를 세팅하는 명령을 통해 이루어진다.


어떤 프로그램이 CPU를 할당받고 명령을 수행하다가 중간에 CPU를 선점당하는 경우는 크게 두 가지 경우로 하나는 타이머에 의해 인터럽트가 발생한 경우, 다른 하나는 입출력 요청을 위해 시스템 콜을 한 경우이다.
* 타이머는 특정 프로그램에 의해 CPU가 독점되는 것을 방지하기 위한 하드웨어로 CPU 할당 시간이 만료되면 인터럽트를 발생 시킨다.
* 타이머는 여러 프로세스가 CPU를 나누어 사용하는 시분할 시스템(time sharing system)의 구현을 위한 필수적인 요소이다.


사용자 프로그램이 디스크에서 파일 데이터를 읽어오는 등의 입출력 요청을 위해 시스템 콜을 하는 경우, 오래 걸리는 입출력 작업이 완료되기까지 그 프로세스에게 CPU를 다시 할당하더라도 당장 다음 명령을 수행하지 못하는 경우가 일반적이므로 CPU를 다른 프로세스에게 이양하게 된다. 입출력을 요청했던 프로세스는 입출력 요청이 완료되어 컨트롤러가 인터럽트를 발생 시킨 시점부터 다시 CPU를 얻을 수 있는 자격을 부여받게 된다.


&nbsp;      
### [by. 0junChoi](https://github.com/0jun0815) email: <0jun0815@gmail.com>
### 출처: [운영 체제와 정보 기술의 원리](http://book.naver.com/bookdb/book_detail.nhn?bid=4392911), [반효경 운영체제 강의](http://www.kocw.net/home/search/kemView.do?kemId=1046323)

