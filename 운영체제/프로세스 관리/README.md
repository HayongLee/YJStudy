# 프로세스 관리


* [프로세스의 생성](#프로세스의-생성)
* [프로세스 간의 협력](#프로세스-간의-협력)


&nbsp;      
## 프로세스의 생성
시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만 그다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성(COW, Copy-on-write)하게 된다. 프로세스를 생성한 프로세스를 부모 프로세스라고 하고 새롭게 생성된 프로세스를 자식 프로세스라고 한다. 이러한 방식을 통해  프로세스는 족보와 같은 계층을 형성하게 된다.


프로세스의 세계에서는 자식이 먼저 죽고, 이에 대한 처리는 자식을 생성했던 부모 프로세스가 담당하는 방식으로 진행된다. 만약 후손들을 여러 단계에 걸쳐 많이 생성한 프로세스가 종료될 경우에는 그 프로세스가 생성했던 모든 후손 프로세스들을 연쇄적으로 종료시킨 후에야 본인이 종료될 수 있다.


생성된 프로세스가 작업을 수행하기 위해서는 자원이 필요하다. 자원을 획득하는 방법은 운영 체제 및 자원의 종류에 따라 상이하다. 어떤 경우에는 운영 체제로부터 직접 자원을 할당받을 수도 있고, 또 다른 경우에는 부모 프로세스와 자원을 공유해서 사용할 수도 있다. 프로세스가 수행되는 모델도 부모와 자식이 공존하며 수행되는 모델과 자식이 종료(terminate) 될 때까지 부모가 기다리는(wait) 모델이 있다. 
* 부모와 자식이 공존하며 수행되는 모델에서는 자식과 부모가 같이 CPU를 획득하기 위해 경쟁하는 관계가 된다. 
* 부모가 자식의 종료를 기다리는 모델에서는 자식 프로세스가 종료될 때까지 부모 프로세스는 아무 일도 하지 않고 봉쇄 상태에 머물러 있다가 자식 프로세스가 종료되면 그때 부모 프로세스가 준비 상태가 되어 다시 CPU를 얻을 권한이 생기게 된다.


프로세스가 생성되면 자신만의 독자적인 주소 공간(address space)을 갖게 된다. 자식 프로세스는 부모 프로세스와는 별도의 주소 공간을 가지게 되는데 처음 주소 공간을 생성할 때에는 부모 프로세스의 주소 공간 내용을 그대로 복사해서 생성하게 된다. 자식 프로세스가 다른 프로그램을 수행하기 위해서는 생성된 주소 공간 위에 새로운 프로그램의 주소 공간을 덮어 씌워 실행하게 되는 것이다.


프로세스의 생성 절차에 대해 유닉스의 예:
1. 유닉스에서는 fork() 시스템 콜을 통해 새로운 프로세스를 생성한다.
2. fork() 시스템 콜은 자식 프로세스를 생성할 때 부모 프로세스의 내용을 그대로 복제 생성하게 된다. 따라서, 부모 프로세스와 자식 프로세스는 비록 주소 공간을 따로 갖게 되지만 주소 공간 내에는 동일한 내용을 가지게 된다. 
3. fork()를 통해 생성된 자식 프로세스는 exec() 시스템 콜을 통해 새로운 프로그램으로 주소 공간을 덮어 씌울 수 있다.


프로세스 종료는 두 가지로 나뉜다.
* 첫 번째는 프로세스가 마지막 명령을 수행한 후 운영 체제에게 이를 알려 이루어지는 자발적 종료이다. 프로세스는 명령(instruction)을 모두 수행한 후, 프로그램이 마쳐지는 코드 부분에 exit()이라는 시스템 콜을 넣어 주도록 되어 있다. 종료를 통보받은 운영 체제는 이 프로세스로부터 자원을 회수하고 시스템 내에서 이 프로세스를 정리하게 된다. 
    * exit() 함수는 명시적으로 호출하지 않아도 프로그램이 종료되는 지점에 컴파일러가 자동으로 삽입해 프로세스의 종료 직전에 호출된다.
* 두 번째는 비자발적 종료로 부모 프로세스가 자식 프로세스의 수행을 강제로 종료 시키는 것이다.
    * abort() 함수를 통해 이루어지며 강제 종료가 발생하는 경우는 다음과 같다:
        * 자식 프로세스가 할당 자원의 한계치를 넘어 많은 양의 자원을 요구할 때
        * 자식 프로세스에게 할당된 작업이 더 이상 필요하지 않을 때
        * 부모 프로세스가 종료(exit) 되는 경우
        * 키보드로 kill, break 등을 친 경우
        
        
부모 프로세스가 종료되는 경우 운영 체제는 자식 프로세스가 더 이상 수행되지 못하게 하기 때문에 단계적인 종료가 발생된다. 종료되는 프로세스의 자식 프로세스를 계속 실행시키기 위해서는 종료되지 않을 다른  프로세스의 양자로 자식 프로세스를 보내어 기존 부모 프로세스가 종료된 후에도 다른 프로세스 아래에서 계속 수행될 수 있도록 하는 방법이 있다.


운영 체제는 자식 프로세스의 생성을 위해 fork() 시스템 콜을 제공한다. 
* 프로세스가 fork() 시스템 콜을 하게 되면 CPU의 제어권이 커널로 넘어가게 되고, 커널은 fork()를 호출한 프로세스를 복제해 자식 프로세스를 생성하게 된다.
* fork()를 통해 생성된 프로세스는 부모 프로세스와 모든 문맥을 동일하게 가지고 있다. 즉, 부모 프로세스의 주소 공간을 비롯해 프로그램 카운터 등 레지스터 상태, PCB 및 커널 스택 등 모든 문맥을 그대로 복제해 자식 프로세스의 문맥을 형성하게 되는 것이다. 따라서, 자식 프로세스는 부모 프로세스의 처음부터 수행을 시작하는 것이 아니라 부모 프로세스가 현재 수행한 시점(프로그램 카운터 지점)부터 수행하게 된다는 것이다. 운영 체제가 프로세스를 관리하기 위해서 사용하는 프로세스 식별자는 부모 프로세스와 다른 식별자를 가지게 된다는 점이 유일한 차이점이다.
* 프로세스가 복제된 프로세스라는 사실을 알 수 있는 단서는 fork()의 결과값으로 원본에게는 양수를 주고 복제본에게는 0을 준다는 점이다.


자식 프로세스에게 부모와는 다른 독자적인 프로그램을 수행시킬 수 있는 메커니즘이 필요하다. 유닉스에서는 exec() 시스템 콜을 지원한다. 
* exec()는 프로세스가 지금까지 수행했던 상태를 잊어버리고 그 주소 공간을 완전히 새로운 프로그램으로 덮어 씌운 후 새로운 프로그램의 첫 부분부터 실행을 다시 시작하도록 하는 시스템 콜이다. 
* 새로운 프로그램을 수행시키기 위해서는 fork()를 통해 기존 프로세스와 동일한 프로세스를 복제한 후 exec()을 통해 새롭게 수행시키려는 프로세스를 자식 프로세스의 주소 공간에 덮어 씌우면 된다.


프로세스와 관련된 시스템 콜에는 fork(), exec(), exit() 이외에도 wait()라는 함수가 있다. 
* wait() 시스템 콜은 자식 프로세스가 종료되기를 기다리며 부모 프로세스가 봉쇄 상태에 머무르도록 할 때에 사용된다. 
* fork() 후에 wait()를 호출하면 커널은 자식 프로세스가 종료될 때까지 부모 프로세스를 봉쇄 상태에 머무르게 하고, 자식 프로세스가 종료되면 부모를 준비 상태로 변경시켜 작업을 재개할 수 있도록 한다. 이러한 방식으로 부모 프로세스와 자식 프로세스 간의 동기화(synchronization)를 가능하게 한다. 
* wait() 시스템 콜을 한 부모 프로세스는 일반적인 봉쇄 상태에서처럼 자원을 기다리며 줄 서 있는 것이 아니라 자식 프로세스가 종료되기를 기다리며 수면 상태에 머무르게 되는 것이며, 자식 프로세스가 종료되는 순간 준비 큐에 재진입해 다시 CPU를 얻을 권한을 획득하게 된다.


&nbsp;
## 프로세스 간의 협력
원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미칠 수 없다. 다른 프로세스와 정보를 주고받을 수 있는 방법이 없기 때문이다. 운영 체제는 프로세스 간의 협력 메커니즘을 제공해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있게 한다.


프로세스 간의 협력 메커니즘을 위해 운영 체제가 제공하는 대표적인 메커니즘으로는 IPC(inter-process communication)가 있다. IPC란 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신을 말한다. 대표적인 방법으로는 메시지 전달(message passing) 방식과 공유 메모리(shared memory) 방식이 있다. 이 두 방식의 차이는 프로세스 사이에 공유 변수(shared variable)를 사용하는가 그렇지 않은가에 있다.
* 스레드는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 동일한 프로세스를 구성하는 스레드들간에는 주소 공간을 공유하므로 협력이 가능하다.


### 메시지 전달
* 메시지 전달 방식은 프로세스 간에 공유 변수를 일체 사용하지 않고 메시지를 주고받으면서 통신하는 방식이다. 이때, 두 프로세스가 주소 공간이 다르므로 메시지 전달을 직접 할 수 없으며 커널이 그 역할을 하게 된다.
* 메시지 통신을 하는 시스템은 커널에 의해 send(message), receive(message)라는 두 가지 연산을 제공받는데 이 두 연산을 통해 프로세스는 전달할 메시지를 운영 체제에게 시스템 콜 방식으로 요청해 전달할 수 있다.
* 운영 체제는 메시지를 주고받는 연산을 특권 명령으로 규정해 커널을 통해서만 가능하도록 하고 있다. 통신하기를 원하는 두 프로세스는 커뮤니케이션 링크(communication link)를 생성한 후 send()와 receive()를 이용해서 메시지를 주고받게 된다.


메시지 전달을 통해 통신하는 방식은 메시지의 전송 대상이 다른 프로세스인지 아니면 메일 박스라는 일종의 저장 공간인지에 따라 직접 통신(direct communication)과 간접 통신(indirect communication)으로 나뉜다. 두 방식의 차이는 연산의 인터페이스에 대한 차이일 뿐 실제 메시지 전송이 이루어지는 내부적인 구현 방식은 커널의 중재에 의해 사실상 동일한 방식으로 이루어진다.


#### 직접 통신
직접 통신에서는 통신하려는 프로세스의 이름을 명시적으로 표시한다. 
* send(P, message)는 프로세스 P에게 메시지를 전송하는 것을 의미하며 receive(Q, message)는 프로세스 Q로부터 메시지를 전달받는 것을 말한다.
* 이러한 방식을 위한 커뮤니케이션 링크는 자동적으로 생성되고, 하나의 링크는 정확히 한 쌍의 프로세스에게 할당되며 또한 각 쌍의 프로세스에게 오직 하나의 링크만이 존재하고, 링크는 단 방향성(unidirectional) 일 수 있으나 대부분의 경우 양방향성(bidirectional)이다.


#### 간접 통신
간접 통신에서는 메시지를 메일 박스(mail box) 또는 포트(port)로부터 전달받는다. 각 메일 박스에는 고유 ID가 있으며 메일 박스를 공유하는 프로세스들만 서로 통신을 하게 된다. 간접 통신에서 사용되는 커뮤니케이션 링크는 프로세스 간에 메일 박스를 공유하는 경우에만 생성된다. 
* 하나의 링크가 여러 프로세스들에게 할당될 수 있으며 각 프로세스의 쌍은 여러 링크를 서로 공유할 수 있다. 또한 링크는 단 방향성 또는 양방향성일 수 있다.
* 간접 통신 방식에서 send(A, message)는 A라는 메일 박스에 메시지를 전송하는 것, receive(A, message)는 A라는 메일 박스로부터 메시지를 전달받는 것을 말한다.
* 간접 통신에서는 메일 박스를 공유하기 때문에 다음과 같은 의문 상황이 발생할 수 있다. P1, P2, P3가 메일 박스 A를 공유하는 경우 P1이 메시지를 보냈다면 P2와 P3 중 어느 프로세스가 메시지를 받게 되는가?
    * 의문 사항을 해결하기 위한 방법으로 2개의 프로세스에게만 링크를 할당하는 방법이 사용될 수 있다. 즉 P2와 P3에게 각각 따로 링크를 생성하는 것이다. 또는 링크에 대한 receive() 연산을 매 시점 하나의 프로세스만이 수행할 수 있도록 하는 방법이 있다. 그렇지 않으면 시스템이 메시지 수신자를 임의로 결정해 누가 메시지를 받았는지 송신자에게 통신해 주는 방식이 사용될 수 있다.


### 공유 메모리
IPC의 또 다른 방식으로는 공유 메모리(shared memory) 방식이 있다. 공유 메모리 방식에서는 프로세스들이 주소 공간의 일부를 공유하게 된다.
* 운영 체제는 공유 메모리를 사용하는 시스템 콜을 지원해, 서로 다른 프로세스들이 그들의 주소 공간 중 일부를 공유할 수 있도록 한다. 
* 공유 메모리 영역은 각자의 주소 공간에 공통적으로 포함되는 영역이므로 여러 프로세스가 읽고 쓰는 것이 가능하다.
* 실제 구현은 프로세스 A와 B가 주소 공간을 독자적으로 가지고 있지만 이 주소 공간이 물리적 메모리에 매핑될 때 공유 메모리 주소 영역에 대해서는 동일한 물리적 메모리 주소로 매핑되는 것이다.
* 공유 메모리 방식은 프로세스 간의 통신을 수월하게 할 수 있는 인터페이스를 제공하지만 서로 간의 데이터 일관성 문제가 유발될 수 있어 프로세스들끼리 직접 동기화 문제를 책임져야 한다.


&nbsp;      
### [by. 0junChoi](https://github.com/0jun0815) email: <0jun0815@gmail.com>
### 출처: [운영 체제와 정보 기술의 원리](http://book.naver.com/bookdb/book_detail.nhn?bid=4392911), [반효경 운영체제 강의](http://www.kocw.net/home/search/kemView.do?kemId=1046323)

