# 디스크 관리 
> 디스크(disk)는 컴퓨터 시스템의 대표적인 2차 저장 장치이다. 메모리는 휘발성(volatile) 저장 장치이므로 컴퓨터에서 수행한 작업의 결과를 영구히 보관하기 위해서는 디스크와 같은 2차 저장 장치를 이용해야 한다.


* [디스크의 구조](#디스크의-구조)
* [디스크 스케줄링](#디스크-스케줄링)
    * [FCFS 스케줄링](#fcfs-스케줄링)
    * [SSTF](#sstf)
    * [SCAN 알고리즘](#scan-알고리즘)
    * [C-SCAN](#c-scan)
    * [LOOK과 C-LOOK](#look과-c-look)
* [Swap-space 관리](#swap-space-관리)
* [RAID](#raid)
* [다중 디스크 환경에서의 스케줄링](#다중-디스크-환경에서의-스케줄링)
* [디스크의 저전력 관리](#디스크의-저전력-관리)
    * [비활성화 기법](#비활성화-기법)
    * [회전 속도 조절 기법](#회전-속도-조절-기법)
    * [디스크의 데이터 배치 기법](#디스크의-데이터-배치-기법)
    * [버퍼 캐슁 및 사전 인출 기법](#버퍼-캐슁-및-사전-인출-기법)
    * [쓰기 전략을 통한 저전력 디스크 기법](#쓰기-전략을-통한-저전력-디스크-기법)


&nbsp;      
## 디스크의 구조
디스크 외부에서는 디스크를 일정한 크기의 저장 공간들로 이루어진 1차원 배열처럼 취급하는데 이 일정한 크기의 저장 공간을 논리 블록(logical block)라고 한다. 디스크에 데이터가 저장될 때에는 논리 블록 단위로 저장되고, 디스크 외부로 입출력이 일어날 때에도 논리 블록 단위로 전송된다. 논리 블록에 저장된 데이터를 접근하기 위해서는 해당 블록의 인덱스 번호를 디스크에 전달해야 한다. 그러면 디스크 컨트롤러는 해당 논리 블록이 저장된 물리적 위치를 찾아 요청된 데이터에 대한 입출력 작업을 수행하게 된다. 이 때 각 논리 블록이 저장되는 디스크 내의 물리적인 위치를 섹터(sector)라고 부른다. 즉, 논리 블록 하나가 섹터 하나와 1대 1로 매핑되어 저장되는 것이다.


디스크의 물리적인 구조는 마그네틱의 원판으로 구성. 하나의 디스크 내에 원판의 수는 하나일 수도 여러 개일 수도 있다. 각각의 원판은 트랙(track)으로 구성되고 각 트랙은 최소한의 단위 정보가 저장되는 섹터로 나뉜다. 여러 개의 원판에서 상대적 위치가 동일한 트랙들의 집합을 실린더(cylinder)라고 부른다. 섹터 0은 최외곽 실린더의 첫 번째 트랙에 있는 첫 번째 섹터이다. 디스크에 데이터를 읽고 쓰기 위해서는 암(arm)이 해당 섹터가 위치한 실린더로 이동한 후 원판이 회전하여 디스크 헤드가 저장된 섹터 위치에 도달해야 한다.


![디스크의 물리적 구조](https://github.com/0jun0815/YJStudy/blob/master/운영체제/디스크%20관리/images/disk.png)


### 디스크 관리
#### Physical formatting(Low-level formatting)
* 디스크를 컨트롤러가 읽고 쓸 수 있도록 섹터들로 나누는 과정
* 각 섹터는 header + 실제 data(보통 512byte) + trailer로 구성
* header와 trailer는 sector number, ECC(Error-Correcting Code) 등의 정보가 저장되며 controller가 직접 접근 및 운영


#### Partitioning
* 디스크를 하나 이상의 실린더 그룹으로 나누는 과정
* OS는 이것을 독립적 disk로 취급(logical disk)


#### Logical formatting
* 파일 시스템을 만드는 것
* FAT, inode, free space 등의 구조 포함


#### Booting
* ROM에 있는 "small bootstrap loader"의 실행
* 섹터 0(boot block)을 로드하여 실행
* 섹터 0은 "full Bootstrap loader program"
* OS를 디스크에서 로드하여 실행


&nbsp;
## 디스크 스케줄링
디스크에 대한 접근 시간(access time)은 탐색 시간(seek time)과 회전 지연 시간(rotational latency), 전송 시간(transfer time)으로 구분된다.
* 탐색 시간은 디스크 헤드를 해당 실린더 위치로 이동시키는 데 걸리는 시간이다.
* 회전 지연 시간은 디스크가 회전해서 읽고 쓰려는 섹터가 헤드 위치에 도달하기까지 걸리는 시간이다.
* 전송 시간은 해당 섹터가 헤드 위치에 도달한 후 데이터를 실제로 섹터에 읽고 쓰는 데 소요되는 시간이다.


디스크 입출력의 효율을 높이기 위해서는 디스크 입출력에 소요되는 접근 시간을 최소화해야 한다. 접근 시간을 최소화하기 위해서는 탐색 시간, 회전 지연 시간, 전송 시간을 줄여야 하는데, 회전 지연 시간과 전송 시간은 상대적인 수치가 작을 뿐 아니라 운영 체제 입장에서 통제하기 힘든 부분이다. 따라서 운영 체제는 탐색 시간을 줄이기 위해 헤드의 움직임을 최소화하는 스케줄링 작업을 한다.


디스크 스케줄링(disk scheduling)이란 효율적인 디스크 입출력을 위해 여러 섹터들에 대한 입출력 요청이 들어왔을 때 이들을 어떠한 순서로 처리할 것인지 결정하는 매커니즘을 말한다. 가장 중요한 목표는 디스크 헤드의 이동 거리를 줄이는 것이다.


### FCFS 스케줄링
FCFS(First Come First Served) 스케줄링은 디스크에 먼저 들어온 요청을 먼저 처리하는 방식이다.


예를 들어 200개의 실린더를 가진 디스크의 입출력 요청이 순서대로(99 -> 184 -> 36 -> 123 -> 15 -> 125 -> 66 -> 68) 들어왔을 경우:


![FCFS 스케줄링의 예](https://github.com/0jun0815/YJStudy/blob/master/운영체제/디스크%20관리/images/fcfs.png)


* 현재 디스크 헤드가 54번 실린더에 있을 경우 헤드는 54에서 출발하여 요청이 들어온 순서대로 이동하게 된다.
* 헤드의 총 이동 거리(54 ->  99 -> 184 -> 36 -> 123 -> 15 -> 125 -> 66 -> 68)는 644가 된다.


이 스케줄링은 효율성이 매우 떨어진다. 그 이유는 디스크 스케줄링의 경우 고정된 장소에서 서비스가 이루어지는 것이 아니라 디스크 헤드가 움직이면서 서비스를 하기 때문이다.


FCFS 스케줄링이 적용되는 디스크에서 최악의 경우 입출력 요청이 디스크의 한쪽 끝과 반대쪽 끝에 번갈아 도착한다면 헤드는 디스크를 계속 왕복하며 일을 처리해야 하므로 탐색 시간이 매우 늘어나는 결과를 초래한다.


### SSTF
SSTF(Shortest Seek Time First) 스케줄링은 헤드의 현재 위치로부터 가장 가까운 위치에 있는 요청을 제일 먼저 처리하는 알고리즘이다.


예를 들어 200개의 실린더를 가진 디스크의 입출력 요청이 순서대로(99 -> 184 -> 36 -> 123 -> 15 -> 125 -> 66 -> 68) 들어왔을 경우:


![SSTF 스케줄링의 예](https://github.com/0jun0815/YJStudy/blob/master/운영체제/디스크%20관리/images/sstf.png)


* 현재 헤드 위치인 54번에서 가장 가까운 66번 실린더의 요청을 먼저 처리하고 그 후 해당 실린더에서 가장 가까운 순서로 이동하며 요청을 처리한다.
* 헤드의 총 이동 거리(54 -> 66 -> 68 -> 36 -> 15 -> 99 -> 123 -> 125 -> 184)는 236이 된다.


SSTF는 헤드의 이동 거리를 줄여 디스크 입출력의 효율성을 증가시키지만, 기아 현상(starvation)을 발생시킬 수 있다. 현재 헤드 위치로부터 가까운 곳에 지속적인 요청이 들어올 경우 헤드 위치에서 멀리 떨어진 곳의 요청은 무한히 기다려야 하는 문제가 발생할 수 있기 때문이다.


FCFS와 비교해 볼 때 헤드의 이동 거리를 많이 줄일 수 있지만 그렇다고 SSTF가 헤드의 이동 거리 측면에서 가장 우수한 알고리즘은 아니다.


### SCAN 알고리즘
SCAN 알고리즘은 헤드가 디스크 원판의 한쪽 끝에서 다른 쪽 끝으로 이동하며, 그 경로에 존재하는 모든 요청을 처리한다. 즉, 디스크의 어떠한 위치에 요청이 들어오는가와 상관없이 헤드는 정해진 방향으로 이동하면서 길목에 있는 요청을 처리하면서 지나가는 것이다.


예를 들어 200개의 실린더를 가진 디스크의 입출력 요청이 순서대로(99 -> 184 -> 36 -> 123 -> 15 -> 125 -> 66 -> 68) 들어왔고, 디스크 헤드가 0번 실린더 방향으로 이동하고 있을 경우:


![SCAN 스케줄링의 예](https://github.com/0jun0815/YJStudy/blob/master/운영체제/디스크%20관리/images/scan.png)


* 현재 헤드 위치인 54번에서 0번 실린더까지 이동하면서 가는 길목에 존재하는 35번과 15번 실린더의 요청을 처리하게 된다.
* 0번 실린더에 도착한 후에는 이동 방향을 바꾸어 199번 실린더를 향해 이동하면서 가는 길목에 존재하는 모든 요청들을 차례로 처리하게 된다.
* 헤드의 총 이동 거리(54 -> 36 -> 15 -> 0 -> 66 -> 68 -> 99 -> 123 -> 125 -> 184)는 238이 된다.


SCAN 알고리즘은 엘리베이터에서 사용하는 스케줄링 알고리즘과 유사하여 엘리베이터 스케줄링 알고리즘(elevator scheduling algorithm)이라고도 부른다.


SCAN 알고리즘은 FCFS처럼 불필요한 헤드의 이동이 발생하거나 SSTF처럼 일부 지역이 지나치게 오래 기다리는 현상이 발생하지 않는다. 즉, 효율성과 형평성을 모두 만족하는 알고리즘이라 할 수 있다. 한쪽 끝에서 다른 쪽 끝으로 한 번만 이동하면 현재 큐에 들어온 모든 요청을 처리할 수 있으므로 이동 거리 측면에서 매우 효율적이고 헤드가 전체 실린더를 한 번 스캔하는 시간이면 기다리던 모든 요청이 처리되므로 일부 요청이 지나치게 오래 기다리는 현상도 발생하지 않는다.


하지만, SCAN 알고리즘에서 모든 실린더 위치의 기다리는 시간이 공평한 것은 아니다. 제일 안쪽이나 제일 바깥쪽 위치보다는 가운데 위치가 기다리는 평균 시간이 더 짧기 때문이다. 헤드가 가운데 위치를 지나가는 주기는 양 끝을 지나가는 주기의 절반에 불과하다. 이런 위치에 따른 탐색 시간의 편차를 보완하기 위해 C-SCAN 알고리즘이 제안되었다.


### C-SCAN
C-SCAN(Circular-SCAN)은 SCAN처럼 헤드가 한쪽 끝에서 다른 쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리한다. 그러나 SCAN과 달리 헤드가 다른 쪽 끝에 도달해 방향을 바꾼 후에는 요청을 처리하지 않고 곧바로 출발점으로 다시 이동만 한다. 이 방식은 SCAN보다 각 실린더 위치에 대해 좀더 균일한 탐색 시간을 제공한다. 즉, SCAN보다 헤드의 이동 거리는 조금 길어지지만 탐색 시간의 편차를 줄일 수 있다는 것이 C-SCAN의 장점이다.


앞선 예제를 C-SCAN 알고리즘에 적용시켰을 때:


![C-SCAN 스케줄링의 예](https://github.com/0jun0815/YJStudy/blob/master/운영체제/디스크%20관리/images/cscan.png)


* 헤드의 총 이동 거리(54 -> 66 -> 68 -> 99 -> 123 -> 125 -> 184 -> 199 -> 0 -> 15 -> 36)는 380이 된다.


### LOOK과 C-LOOK
LOOK은 헤드가 한쪽 방향으로 이동중이다가 그 방향으로 전방에 더 이상 대기중인 요청이 없으면 헤드의 이동 방향을 즉시 반대 방향으로 바꾸는 스케줄링 방식이다. 헤드가 진행하는 방향에 요청이 있는지를 살핀 후 이동하기 때문에 LOOK이라고 부르는 것이다.


C-LOOK은 전방에 요청이 없을 때 방향을 바꾼다는 측면에서는 LOOK과 유사하며, 한쪽 방향으로 이동할 때에만 요청을 처리한다는 점에서 C-SCAN과 유사하다.


앞선 예제를 C-LOOK 알고리즘에 적용시켰을 때:


![C-LOOK 스케줄링의 예](https://github.com/0jun0815/YJStudy/blob/master/운영체제/디스크%20관리/images/c-look.png)


* C-SCAN과의 차이점은 헤드가 184번 실린더까지 이동한 후 전방에 더 이상의 요청이 없으므로 199번까지 가는 대신 곧바로 방향을 바꾼다는 점이다. 또한, 헤드가 0번까지 이동하는 것이 아니라 요청이 존재하는 가장 낮은 실린더 번호까지만 이동해 서비스를 시작하므로 15번 실린더에서 다시 방향을 바꾸게 된다.
* 헤드의 총 이동 거리(54 -> 66 -> 68 -> 99 -> 123 -> 15 -> 36)는 198이 된다.


SCAN, C-SCAN 및 이들을 좀더 활용한 LOOK, C-LOOK 등의 스케줄링 알고리즘이 디스크 입출력이 많은 시스템에서 FCFS나 SSTF에 비해 효율적인 것으로 알려져 있다.


&nbsp;
## Swap-space 관리
디스크를 사용하는 두 가지 이유:
* 메모리의 volatile(휘발성)한 특성 -> 파일 시스템
* 프로그램 실행을 위한 메모리 공간 부족 -> swap space(swap area)


Swap-space
* 가상 메모리 시스템에서는 디스크를 메모리의 연장공간으로 사용
* 파일 시스템 내부에 둘 수 있으나 별도 partition 사용이 일반적
    * 공간 효율성보다는 속도 효율성이 우선
    * 일반 파일보다 훨씬 짧은 시간만 존재하고 자주 참조됨
    * 따라서, block의 크기 및 저장 방식이 일반 파일 시스템과 다름


&nbsp;
## RAID
RAID(Redundant Array of Independent Disks)는 여러 개의 디스크를 묶어서 사용하는 것을 의미한다.


RAID의 사용 목적:
* 디스크 처리 속도 향상
    * 여러 디스크에 block의 내용을 분산 저장
    * 병렬적으로 읽어 옴(interleaving, striping)
* 신뢰성(reliability) 향상
    * 동일 정보를 여러 디스크에 중복 저장
    * 하나의 디스크가 고장(failure)시 다른 디스크에서 읽어옴(Mirroring, shadowing)
    * 단순한 중복 저장이 아니라 일부 디스크에 parity를 저장하여 공간의 효율성을 높일 수 있다.


&nbsp;
## 다중 디스크 환경에서의 스케줄링
포털 사이트 등 수많은 동시 사용자를 서비스하는 서버에서는 다수의 디스크를 함께 사용한다. 동일한 정보를 여러 디스크에 중복 저장함으로써, 인기 있는 데이터를 여러 디스크로부터 동시에 서비스할 수 있고, 일부 디스크에 오류가 발생할 때에도 지속적인 서비스가 가능하며, 정보의 유실을 방지할 수 있기 때문이다. 이처럼 다중 디스크를 사용하면 시스템의 성능과 신뢰성을 동시에 향상시킬 수 있다.


이러한 환경에서는 같은 데이터가 저장되어 있는 여러 개의 디스크 중 어느 디스크에서 요청을 처리할지 결정하는 스케줄링 문제가 발생한다. 앞서 설명한 스케줄링 기법이 하나의 디스크 내에서 입출력 요청의 처리 순서를 결정하는 것이라면, 다중 디스크에서의 스케줄링은 작업을 수행할 디스크를 결정하는 문제까지 포함한다. 이러한 시스템에서는 스케줄링의 목표에 따라 요청을 처리할 디스크를 결정하는 기준이 달라진다. 거시적인 관점에서는 각 디스크 간의 부하 균형(load balancing)을 이루도록 스케줄링하는 것이 중요하다. 다중 디스크는 많은 요청을 동시에 처리할 수 있는 확장성 있는 서비스가 목표이므로 일부 디스크가 과부하 상태에 이르지 않고 모든 디스크에 요청이 골고루 분배되도록 스케줄링해야 하기 때문이다.


최근에는 전력 소모를 줄이는 것이 디스크 관리의 또 다른 중요한 목표로 인식되고 있다. 전력 절감 측면에서는 모든 디스크에 요청을 골고루 분산시키기보다는 일부 디스크에 요청을 집중시키고 나머지 디스크는 회전을 정지시키는 것이 더 효과적이다. 이는 요청이 빈번하지 않은 상황에 한해서 성립하는 이야기이다.


&nbsp;
## 디스크의 저전력 관리
### 비활성화 기법
디스크의 상태는 전력 소모를 기준으로 크게 네 가지 상태인 활동(active) 상태, 공회전(idle) 상태, 준비(standby) 상태, 휴면(sleep) 상태로 나누어 볼 수 있다.
* 활동 상태는 현재 헤드가 데이터를 읽거나 쓰고 있는 상태이다.
* 공회전 상태는 디스크가 회전중이지만 데이터를 읽거나 쓰지는 않는 상태이다.
* 준비 상태는 디스크가 회전하지 않지만 인터페이스가 활성화된 상태이다.
* 휴면 상태는 디스크가 회전하지 않고 인터페이스도 비활성화된 상태이다.


편의상 디스크가 회전중인 활동 상태와 공회전 상태를 활성 상태라고 부르고, 디스크가 정지한 준비 상태와 휴면 상태를 비활성 상태라고 부른다.


활성 상태보다는 비활성 상태에서 전력 소모가 적으므로 요청이 없을 경우 디스크를 정지시키는 것이 전력 절감 측면에서 효과적이다. 그러나, 각 상태로의 전환시에는 부가적인 전력 및 시간이 소모된다. 

예를 들어 비활성 상태에서 데이터를 읽고 쓰려면 활성 상태일 때보다 1~3초의 부가적인 시간과 1~2배의 부가적인 전력 소모가 뒤따르게 된다. 따라서, 후속 요청까지의 시간 간격이 일정 시간(break-even time) 이상일 경우에만 디스크의 회전을 정시시키는 것이 전력 소모 절감에 효과적이다. 이는 장치를 비활성화시킬 시점을 결정하기 위해 미래의 요청이 도착하는 시점과 간격을 정확히 예측하는 것이 중요함을 뜻한다.


디스크를 비활성화시키는 시점을 결정하는 방법으로는 시간 기반(timeout based) 기법과 예측 기반(prediction based) 기법, 확률 기반(stochastic based) 기법이 있다.
* 시간 기반 기법에서는 일정 시간 동안 디스크가 공회전 상태이면 장치를 정지시켰다가, 다시 요청이 왔을 때 디스크를 활성화시킨다.
* 예측 기반 기법에서는 과거 요청에 대한 관찰을 통해 다음 공회전 구간의 길이를 예측해서, 디스크를 비활성화시킬 시점을 결정한다.
* 확률 기반 기법에서는 디바이스의 상태 변경 시간 간격을 구하기 위해 확률 분포를 통해 요청을 모델링하고 마르코프 체인(Markov chain)등과 같은 통계적 모델을 이용한다.


### 회전 속도 조절 기법
디스크의 전력 소모를 줄이기 위한 방법으로 디스크의 회전 속도(RPM)를 가변적으로 조절하는 기법. 운영 체제는 시스템 자원과 부하를 포괄적으로 불 수 있기 때문에, 하드웨어 혼자서 전력 관리를 하는 것에 비해 더 많은 전력 절감 효과를 얻을 수 있다.


### 디스크의 데이터 배치 기법
대부분의 컴퓨터 시스템에서 디스크의 53% 이상이 빈 공간인 상태로 남아 있다는 점에 착안해서 디스크 내에 데이터의 복제본(replica)을 많이 만들어 헤드 위치에서 가까운 복제본을 접근하도록 하여 빠른 응답 시간과 전력 소모량 절감을 얻는 FS2 파일 시스템(free space file system). 복제본이 있는 경우 쓰기 연산에서 일관성(consistency) 문제가 발생할 수 있으나 FS2에서는 헤드의 위치에서 가까운 복제본에 쓰고 나머지 복제본들에 대해서는 주소 테이블에 무효화(invalidation) 연산만을 수행해 쓰기 연산의 효율성까지 높이는 방법.


### 버퍼 캐슁 및 사전 인출 기법
디스크가 저전력 모드일 때는 입출력 처리를 최대한 지연시켰다가 디스크가 정상 전력 모드로 돌아왔을 때 사전 인출을 공격적으로 하여 디스크의 상태 변화 횟수를 최소화하는 방법


### 쓰기 전략을 통한 저전력 디스크 기법
대상 디스크가 비활성 상태일 때에는 디스크 쓰기를 하지 않고 기다렸다가, 디스크가 활성 상태로 돌아왔을 때 쓰는 방식(write-back with eager updates)으로 전력 소모를 줄이는 방법


&nbsp;
&nbsp;      
### [by. 0junChoi](https://github.com/0jun0815) email: <0jun0815@gmail.com>
### 출처: [운영 체제와 정보 기술의 원리](http://book.naver.com/bookdb/book_detail.nhn?bid=4392911), [반효경 운영체제 강의](http://www.kocw.net/home/search/kemView.do?kemId=1046323)

