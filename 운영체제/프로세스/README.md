# 프로세스


* [프로세스의 개념](#프로세스의-개념)
* [프로세스의 상태](#프로세스의-상태)
* [프로세스의 두 가지 실행 상태](#프로세스의-두-가지-실행-상태)
* [프로세스 제어 블록(PCB)](#프로세스-제어-블록pce)
* [문맥 교환](#문맥-교환)
* [프로세스를 스케줄링하기 위한 큐](#프로세스를-스케줄링하기-위한-큐)
* [스케줄러](#스케줄러)
    * [장기 스케줄러](#장기-스케줄러)
    * [단기 스케줄러](#단기-스케줄러)
    * [중기 스케줄러](#중기-스케줄러)
* [스레드](#스레드)


&nbsp;      
## 프로세스의 개념
프로세스(process)란 수행 중인 프로그램(program in execution)으로 JOB이라는 용어와 혼용해 사용하기도 한다. 프로세스의 문맥이란 프로세스가 현재 어떤 상태에서 수행되고 있는지를 정확히 규명하기 위해 필요한 정보를 의미한다.


여러 프로세스가 함께 수행되는 시분할 시스템 환경에서는 타이머 인터럽트에 의해 짧은 시간 동안 CPU를 사용한 후 CPU를 선점당했다가 추후에 다시 CPU를 획득하는 식으로 CPU 관리가 이루어진다. CPU를 다시 획득해 명령의 수행을 재개하는 시점이 되면 지난번 CPU 보유 시기에 어느 부분까지 명령을 수행했는지 직전 수행 시점의 정확한 상태를 재현할 필요가 있다. 이때, 정확한 재현을 위해 필요한 정보가 바로 프로세스의 문맥이다.


프로세스의 문맥은 그 프로세스의 주소 공간(코드, 데이터, 스택 상태)을 비롯해 레지스터에 어떤 값을 가지고 있었는지와 시스템 콜 등을 통해 커널에서 수행한 일의 상태, 그 프로세스에 관해 커널이 관리하고 있는 각종 정보(PCB) 등을 포함하게 된다.


프로세스의 문맥을 크게 세 가지로 분류하면 하드웨어 문맥, 프로세스의 주소 공간, 커널 상의 문맥으로 나뉜다.
* 하드웨어 문맥은 CPU의 수행 상태를 나타내는 것으로 프로그램 카운터 값과 각종 레지스터에 저장하고 있는 값들을 의미한다.
* 프로세스의 주소 공간은 그 프로세스의 문맥을 결정짓는 중요한 요소 중 하나이다.
* 프로세스를 관리하기 위한 자료 구조로는 PCB와 커널 스택이 해당하며 이 또한 프로세스의 문맥을 구성하는 중요한 요소가 된다.


&nbsp;      
## 프로세스의 상태
프로세스의 상태는 실행(running), 준비(ready), 봉쇄(blocked, wait, sleep)의 세 가지로 구분할 수 있다.
* 실행 상태는 프로세스가 CPU를 보유하고 기계어 명령을 실행하고 있는 상태로 일반적인 컴퓨터 시스템 내에 CPU는 하나뿐이므로 실행 상태에 있는 프로세스는 매 시점 하나뿐이다.
* 준비 상태는 프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태를 가리킨다.
* 봉쇄 상태는 프로세스에게 CPU를 주어도 당장 명령을 실행할 수 없는 상태이다.


이 밖에도 시작 상태와 완료 상태가 있는데 시작 상태는 프로세스가 시작되어 그 프로세스를 위한 각종 자료 구조는 생성되었지만 아직 메모리 획득을 승인받지 못한 상태를 말하고, 완료 상태는 프로세스가 종료되었으나 운영 체제가 그 프로세스와 관련된 자료 구조를 완전히 정리하지 못한 상태를 말한다.


![프로세스 상태도](https://github.com/0jun0815/YJStudy/blob/master/운영체제/프로세스/images/프로세스%20상태도1.png)


하나의 프로세스는 항상 어느 한 상태에 머물러 있게 된다. 그리고, 그 상태는 시간이 흐름에 따라 변하게 된다.


실행시킬 프로세스를 변경하기 위해 원래 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정을 문맥 교환(context switch)이라고 한다. 문맥 교환이 일어나는 때는 타이머 인터럽트가 발생하는 경우 외에도 실행 상태에 있던 프로세스가 입출력 요청 등으로 봉쇄 상태로 바뀌는 경우를 들 수 있다.


준비 상태에 있는 프로세스들 중에서 CPU를 할당받을 프로세스를 선택한 후 실제로 CPU의 제어권을 넘겨받는 과정을 CPU 디스패치(dispatch)라고 한다.


입출력을 요청한 프로세스의 상태 변화 예:


![프로세스의 상태1](https://github.com/0jun0815/YJStudy/blob/master/운영체제/프로세스/images/프로세스의%20상태1.png)
![프로세스의 상태2](https://github.com/0jun0815/YJStudy/blob/master/운영체제/프로세스/images/프로세스의%20상태2.png)


1. 실행 상태인 프로세스가 입출력을 요청할 경우, 입출력이 완료될 때까지 CPU를 반환한 다음 디스크 입출력 서비스를 기다리는 장치 큐에 가서 줄을 서게 되며 이때 프로세스의 상태는 봉쇄 상태가 된다.
2. 그러면, CPU를 기다리는 준비 큐에 줄 서 있는 프로세스들 중에서 CPU 스케줄러가 적절한 프로세스를 하나 선정해서 CPU를 할당하고 CPU를 기다리는 준비 큐에는 입출력 등 오래 기다려야 하는 업무가 진행 중인 프로세스는 줄 서 있지 못하고 CPU만 획득하면 곧바로 명령을 수행할 수 있는 프로세스들만 줄 서 있게 된다. 이러한 상태를 준비 상태라고 한다.
3. 준비 상태의 프로세스 중에서 이번에 CPU를 할당받은 프로세스의 상태는 실행 상태로 변경된다.
4. 입출력을 요청한 프로세스는 디스크 입출력을 기다리는 장치 큐에 줄 서 있다가 자기 차례가 되어 디스크 컨트롤러로부터 서비스를 받고 나면 디스크 컨트롤러가 CPU에게 인터럽트를 발생시켜 입출력이 완료되었다는 것을 알리게 된다.
5. CPU는 인터럽트가 발생한 것을 확인하고 그에 대응하는 루틴을 수행, 이 루틴이 진행되는 동안 CPU에서 수행되던 프로세스의 상태는 사용자 모드 실행 상태에서 커널 모드 실행 상태로 바뀌게 된다. 이 루틴이 하는 일은 입출력이 완료된 프로세스를 장치 큐에서 빼내어 CPU를 기다리는 준비 큐에 넣어 주고 프로세스의 상태를 준비 상태로 바꾼 후 장치의 로컬 버퍼에 있는 내용을 메모리로 이동시키는 일련의 업무이다.
6. 인터럽트 처리가 끝나면 인터럽트 처리 루틴 이전에 수행되던 프로세스에게 CPU를 다시 할당해 그 프로세스의 상태가 커널 모드에서 다시 사용자 모드 실행 상태로 변경, 경우에 따라서는 인터럽트 발생 전에 수행되던 프로세스가 아니라 방금 입출력을 끝낸 프로세스에게 CPU를 할당하는 경우도 있는데 일반적인 경우는 아니다.


&nbsp;      
## 프로세스의 두 가지 실행 상태
프로그램이 시작되어 종료될 때까지 다양한 함수 호출을 하며 실행되는데 이를 사용자 모드와 커널 모드의 실행 상태로 구분 지을 수 있다.


프로그램이 사용자 정의 함수나 라이브러리 함수를 호출할 때에는 모드의 변경 없이 사용자 모드에서 실행을 지속하고 시스템 콜을 하는 경우에는 커널 모드로 진입해 커널의 주소 공간에 정의된 함수를 실행한다. 시스템 콜의 실행이 끝나면 다시 사용자 모드로 복귀해서 시스템 콜 이후의 명령들을 계속 실행하고 프로그램의 실행이 끝날 때에는 커널 모드로 진입해 프로그램을 종료하게 된다.


프로세스 A가 시스템 콜 호출하면 커널의 코드가 실행되지만 사실상 프로세스 A가 해야 할 일을 대행하는 것이기 때문에 시스템 콜이 실행 중일 때에도 여전히 프로세스 A는 실행 상태에 있는 것으로 간주한다.


CPU의 제어권이 사용자 모드에서 커널 모드로 변경되는 경우는 시스템 콜 외에 하드웨어 인터럽트가 발생한 경우도 있다. 프로세스 A가 실행되던 중 인터럽트가 발생하면 발생 원인과 관계없이 프로세스 A가 사용자 모드에서 실행되다가 커널 모드로 진입한 것으로 간주한다.


&nbsp;      
## 프로세스 제어 블록(PCB)
프로세스 제어 블록(PCB: Process Control Block)이란 운영 체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스당 유지하는 정보들을 담는 커널 내의 자료 구조로 다음과 같은 구성 요소를 갖는다:
* 프로세스의 상태(process state)
* 프로그램 카운터 값(program counter)
* CPU 레지스터(CPU register)
* CPU 스케줄링 정보(CPU scheduling information)
* 메모리 관리 정보(memory management information)
* 자원 사용 정보(accounting information)
* 입출력 상태 정보(I/O status information)


프로세스의 상태는 CPU를 할당해도 되는지 여부를 결정하고 프로그램 카운터 값은 다음에 수행할 명령의 위치를 가리킨다. CPU 레지스터는 CPU 연산을 위해 현시점에 레지스터에 어떤 값을 저장하고 있는지를 나타낸다. CPU 스케줄링 정보와 메모리 관리 정보는 각각 그 프로세스의 CPU 스케줄링과 메모리 할당을 위해 필요한 정보이다. 자원 사용 정보는 사용자에게 자원 사용 요금을 계산해 청구하는 등의 용도로 사용된다.


&nbsp;      
## 문맥 교환
문맥 교환(context switch)이란 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정.


* 사용자 프로세스가 CPU를 할당받고 실행되던 중 타이머 인터럽트가 발생하면 CPU의 제어권은 운영 체제에게 넘어가고 운영 체제는 직전까지 수행 중이던 프로세스의 문맥을 저장하고 새롭게 실행시킬 프로세스에게 CPU를 이양하게 된다.
* 문맥 교환 중 원래 CPU를 보유하고 있던 프로세스는 프로그램 카운터 값 등 프로세스의 문맥을 자신의 PCB에 저장하고 새롭게 CPU를 할당받을 프로세스는 예전에 저장했던 자신의 문맥을 PCB로부터 실제 하드웨어로 복원시키는 과정을 거치게 된다. 
* 문맥 교환은 타이머 인터럽트가 발생하는 경우 외에도 실행 중이던 프로세스가 입출력 요청이나 다른 조건을 충족하지 못해 CPU를 회수당하고 봉쇄 상태가 되는 경우에도 발생할 수 있다.


프로세스가 실행 상태일 때 시스템 콜이나 인터럽트가 발생하면 CPU의 제어권이 운영 체제에게로 넘어가는데 이 경우에도 CPU의 실행 위치 등 프로세스의 문맥 중 일부를 PCB에 저장하게 되지만 이러한 과정을 문맥 교환이라고 하지는 않는다. 사용자 모드에서 실행되다가 커널 모드로 실행 모드만 바뀐 것일 뿐 CPU를 점유하는 프로세스가 다른 사용자 프로세스로 변경되는 과정이 아니기 때문이다. 이와 같은 모드 변경에 비해 문맥 교환에는 훨씬 많은 오버헤드(overhead)가 뒤따르게 된다.


타이머 인터럽트가 발생하거나 프로세스가 입출력 요청 시스템 콜을 하여 봉쇄 상태에 들어가는 경우에는 문맥 교환이 일어나지만, 그 밖의 인터럽트나 시스템 콜 발생 시에는 문맥 교환이 일어나지 않고 모드 변경만이 있을 뿐이다.


문맥 교환에 소요되는 시간은 일종의 오버헤드라고 할 수 있다. 타이머에 CPU 할당 시간을 아주 작게 세팅해 프로세스 간에 문맥 교환이 빈번히 발생하도록 하면 이에 드는 오버헤드가 상당히 커지게 된다. 그 반대로 CPU 할당 시간을 너무 크게 설정하게 되면 시분할 시스템의 의미가 퇴색하게 되므로 적절한 CPU 할당 시간을 정하는 것이 중요하다.


&nbsp;      
## 프로세스를 스케줄링하기 위한 큐
프로세스를 스케줄링하기 위한 큐에는 작업 큐(job queue), 준비 큐(ready queue), 장치 큐(device queue) 등이 있다.
* 작업 큐는 시스템 내의 모든 프로세스를 관리하기 위한 큐로 프로세스의 상태와 무관하게 현재 시스템 내에 있는 모든 프로세스가 작업 큐에 속하게 된다. 작업 큐에 있다고 해서 반드시 메모리를 가지고 있는 것은 아니다.
* 준비 큐는 CPU를 할당받고 실행되기 위해 기다리고 있는 프로세스의 집합을 말한다. 준비 큐에 있는 프로세스들은 준비 상태이다.
* 장치 큐는 각각의 장치마다 서비스를 기다리며 줄 서 있는 프로세스의 큐로 장치 큐에 속한 프로세스는 봉쇄 상태에 있게 된다.
* 작업 큐가 가장 넓은 개념이고 준비 큐와 장치 큐에 있는 프로세스들은 모두 작업 큐에 속해 있다.
* 장치 큐는 각각의 자원마다 큐가 하나씩 존재한다.
* 큐 헤더(queue header)는 큐의 가장 앞 부분을 말한다.
* 큐는 각 프로세스의 PCB를 연결 리스트 형태로 줄 세우게 되며 포인터를 사용해 순서를 정하게 된다.
* 입출력 요청이 발생하면 해당 장치 큐에 가서 줄을 서게 된다. 장치 큐에 속한 프로세스들은 봉쇄 상태에 있다가 해당 장치의 서비스를 받고 나서 장치 컨트롤러가 인터럽트를 발생시키면 준비 상태로 바뀌어 준비 큐로 이동하게 된다.


&nbsp;      
## 스케줄러
스케줄러(scheduler)란 어떤 프로세스에게 자원을 할당할지 결정하는 운영 체제 커널의 모듈을 지칭하며 장기 스케줄러(long term scheduler)와 단기 스케줄러(short term scheduler)가 있다.


### 장기 스케줄러
장기 스케줄러(Long-term scheduler)는 작업 스케줄러(job sceduler)라고도 부르며, 어떤 프로세스를 준비 큐에 삽입할지를 결정하는 역할을 한다. 프로세스에게 메모리를 할당하는 문제에 관여하며 처음 프로세스가 생성되면 시작 상태를 거쳐 준비 상태에 이르게 되는데 장기 스케줄러는 시작 상태의 프로세스들 중 어떠한 프로세스를 준비 큐에 삽입할 것인지를 결정하는 역할을 하게 된다.


### 단기 스케줄러
단기 스케줄러(Short-term scheduler)는 CPU 스케줄러라고도 하며, 준비 상태의 프로세스 중에서 어떤 프로세스를 다음번에 실행 상태로 만들 것인지(CPU를 할당할 것인가)를 결정한다. 시분할(time sharing) 시스템에서는 타이머 인터럽트가 발생하면 단기 스케줄러가 호출된다.


스케줄러는 종류에 따라 각각 고유한 특성을 가진다:
* 단기 스케줄러는 밀리 세컨드(ms) 이하의 시간 단위로 매우 빈번하게 호출되기 때문에 수행 속도가 충분히 빨라야 한다. 장기 스케줄러는 수십 초 내지 수 분 단위로 가끔 호출되기 때문에 속도가 느린 것이 허용된다.
* 장기 스케줄러는 메모리에 동시에 올라가 있는 프로세스의 수(degree of multiprogramming)을 조절하는 역할을 한다. 이는 시작 상태의 프로세스에게 메모리 할당을 승인할지 여부를 장기 스케줄러가 결정하기 때문이다. 그러나, 현대 시분할 시스템에서 사용되는 운영 체제에는 장기 스케줄러를 두지 않는 경우가 대부분이다. 현대의 시분할 시스템용 운영 체제에서는 프로세스가 시작 상태가 되면 장기 스케줄러 없이 곧바로 그 프로세스에 메모리를 할당해 준비 큐에 넣어 주게 된다.


### 중기 스케줄러
현대의 시분할 시스템용 운영체제에서는 장기 스케줄러 대신에 중기 스케줄러(medium term scheduling)를 두는 경우가 많다. 중기 스케줄러는 너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우 이를 해결하기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절하기 위해 추가된 스케줄러이다.


중기 스케줄러는 메모리에 올라와 있는 프로세스 중 일부를 선정해 이들로부터 메모리를 통째로 빼앗아 그 내용을 디스크의 스왑 영역에 저장해 둔다(스왑 아웃). 즉, 중기 스케줄러는 프로세스당 보유 메모리량이 지나치게 적어진 경우 이를 완화시키기 위해 일부 프로세스를 메모리에서 디스크로 스왑 아웃 시키는 역할을 수행한다.


중기 스케줄러가 일부 프로세스를 메모리에서 디스크로 스왑 아웃 시켜야 하는 경우 그 0순위인 프로세스는 봉쇄 상태에 있는 프로세스들이다. 봉쇄 상태인 프로세스들의 경우 당장 CPU를 획득할 가능성이 없기 때문에 메모리를 보유하고 있는 것 또한 큰 의미가 없기 때문이다. 봉쇄 상태인 프로세스를 모두 스왑 아웃시킨 후에도 메모리 공간이 부족한 경우 중기 스케줄러는 보통 타이머 인터럽트가 발생해 준비 큐로 이동하는 프로세스를 추가적으로 스왑 아웃시킨다. 준비 큐에 너무 많은 프로세스들이 존재하면 개별 프로세스에 배당된 메모리량이 지나치게 적어질 뿐 아니라 CPU를 한 번 할당받은 후 다시 할당받기까지 오랜 시간이 소요되기 때문이다.


중기 스케줄러의 등장으로 인해 프로세스의 상태는 실행, 준비, 봉쇄 외에 하나의 상태가 더 추가된다. 외부적인 이유로 프로세스의 수행이 정지된 상태를 나타내는 중지(suspended, stopped) 상태이다.
* 중지 상태에 있는 프로세스는 외부에서 재개시키지 않는 이상 다시 활성화될 수 없으므로 메모리 자원이 당장 필요하지 않다. 따라서, 중지 상태의 프로세스는 메모리를 통째로 빼앗기고 디스크로 스왑 아웃된다.


중지 상태는 중지 준비 상태와 중지 봉쇄 상태로 세분화할 수 있다.
* 준비 상태에 있던 프로세스가 중기 스케줄러에 의해 디스크로 스왑 아웃되면 이 프로세스의 상태는 중지 준비(suspended ready) 상태가 된다. 봉쇄(block) 상태에 있던 프로세스가 중기 스케줄러에 의해 스왑 아웃되면 이 프로세스의 상태는 중지 봉쇄(suspended block) 상태가 된다.
* 중지 봉쇄 상태이던 프로세스가 봉쇄되었던 조건을 만족하게 되면 이 프로세스의 상태는 중지 준비 상태로 바뀌게 된다.


중지 상태에 있는 프로세스들은 메모리를 조금도 보유하지 않고 디스크에 통째로 스왑 아웃된 상태로 존재하게 된다.


![프로세스 상태도2](https://github.com/0jun0815/YJStudy/blob/master/운영체제/프로세스/images/프로세스%20상태도2.png)


&nbsp;
## 스레드
스레드(thread)는 어떠한 프로세스 내에서 실행되는 흐름의 단위를 말한다. 일반적으로 한 프로그램은 하나의 스레드를 가지고 있지만, 프로그램 환경에 따라 둘 이상의 스레드를 동시에 실행할 수 있다. 이러한 실행 방식을 다중 스레드(multithread)라고 한다.


스레드의 구성:
* program counter
* register set
* stack space


스레드가 동료 스레드와 공유하는 부분(=task):
* code section
* data section
* os resources


![스레드1](https://github.com/0jun0815/YJStudy/blob/master/운영체제/프로세스/images/스레드1.png)


전통적인 개념의 heavyweight process는 하나의 스레드를 가지고있는 태스크(task)로 볼 수 있다.


![스레드2](https://github.com/0jun0815/YJStudy/blob/master/운영체제/프로세스/images/스레드2.png)


스레드의 장점:
* 다중 스레드로 구성된 태스크 구조에서는 하나의 서버 스레드가 blocked(waiting) 상태인 동안에도 동일한 태스크 내의 다른 스레드가 실행(running)되어 빠른 처리를 할 수 있다.
* 동일한 일을 수행하는 다중 스레드가 협력하여 높은 처리율(throughput)과 성능 향상을 얻을 수 있다.
* 스레드를 사용하면 병렬성을 높일 수 있다.


&nbsp;      
### [by. 0junChoi](https://github.com/0jun0815) email: <0jun0815@gamil.com>
### 출처: [운영 체제와 정보 기술의 원리](http://book.naver.com/bookdb/book_detail.nhn?bid=4392911), [반효경 운영체제 강의](http://www.kocw.net/home/search/kemView.do?kemId=1046323)

