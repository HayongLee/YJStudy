# 메모리 관리 


* [주소 바인딩](#주소-바인딩)
* [메모리 관리와 관련된 용어](#메모리-관리와-관련된-용어)
    * [동적 로딩 dynamic loding](#동적-로딩-dynamic-loding)
    * [동적 연결 dynamic linking](#동적-연결-dynamic-linking)
    * [중첩 overlays](#중첩-overlays)
    * [스와핑 swapping](#스와핑-swapping)
* [물리적 메모리의 할당 방식](#물리적-메모리의-할당-방식)
    * [연속 할당 방식](#연속-할당-방식)
        * [고정 분할 방식](#고정-분할-방식)
        * [가변 분할 방식](#가변-분할-방식)
    * [불연속 할당 방식](#불연속-할당-방식)
* [페이징 기법](#페이징-기법)
    * [주소 변환 기법](#주소-변환-기법)
    * [페이지 테이블의 구현](#페이지-테이블의-구현)
    * [계층적 페이징](#계층적-페이징)
    * [역 페이지 테이블](#역-페이지-테이블)
    * [공유 페이지](#공유-페이지)
    * [메모리 보호](#메모리-보호)
* [세그먼테이션](#세그먼테이션)
* [페이지드 세그먼테이션](#페이지드-세그먼테이션)


&nbsp;      
## 주소 바인딩
논리적 주소(logical address) 또는 가상 주소(virtual address)는 프로그램이 실행을 위해 메모리에 적재될때 그 프로세스를 위해 생성되는 독자적인 주소 공간으로 각 프로세스마다 독립적으로 할당되며 0번지 부터 시작된다.


물리적 주소(physical address)는 물리적 메모리에 실제 올라가는 위치로 낮은 주소 영역에는 운영체제, 높은 주소 영역에는 사용자 프로세스들이 올라간다.


주소 바인딩(address binding)은 프로세스의 논리적 주소를 물리적 메모리 주소로 연결시켜주는 작업이다.

주소 바인딩의 방식은 프로그램이 적재되는 물리적 메모리의 주소가 언제 결정되느냐에 따라 세 가지로 분류할 수 있다:
* 컴파일 타임 바인딩(compile time binding): 물리적 메모리 주소가 프로그램을 컴파일할 때에 결정되는 주소 바인딩 방식, 절대 코드(absolute code)를 생성하는 바인딩 방식이라고도 한다. 만약 프로그램이 올라와 있는 물리적 메모리의 위치를 변경하려면 컴파일러를 다시 해야 한다. 이 방식은 비현실적이고 현대의 시분할 컴퓨팅 환경에서는 잘 사용하지 않는 기법이다.
* 로드 타임 바인딩(load time binding): 프로그램의 실행이 시작될 때 물리적 메모리 주소가 결정되는 주소 바인딩 방식, 로더(loader)의 책임 하에 물리적 메모리 주소가 부여되며 프로그램이 종료될 때까지 물리적 메모리 상의 위치가 고정된다. 컴파일러가 재배치 가능 코드(reloca-table code)를 생성한 경우에만 가능한 방식이다.
    * 로더: 사용자 프로그램을 메모리에 적재시키는 프로그램
* 실행 시간 바인딩(execution time binding or run time binding): 프로그램이 실행을 시작한 후에도 그 프로그램이 위치한 물리적 메모리 상의 주소가 변경될 수 있는 바인딩 방식, CPU가 주소를 참조할 때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지 주소 매핑 테이블(address mapping table)을 이용해 바인딩을 점검해야 한다. 이 방식은 기준 레지스터(base register)와 한계 레지스터(limit register), MMU(Memory Management Unit: 메모리 관리 유닛)라는 하드웨어적인 지원이 뒷받침되어야 한다. 


MMU는 논리적 주소를 물리적 주소로 매핑해 주는 하드웨어 장치로 주소 변환을 수행하는 MMU 기법(MMU sheme)에 사용된다.
* MMU 기법: CPU가 특정 프로세스의 논리적 주소를 참조하려고 할 때 그 주소값에 기준 레지스터의 값을 더해 물리적 주소값을 얻어낸다. MMU 기법에서는 프로그램의 주소 공간이 물리적 메모리의 한 장소에 연속적으로 적재되는 것으로 가정, 적재되는 물리적 메모리 상의 시작 주소만 알면 주소 변환을 쉽개 할 수 있다.
    * 기준 레지스터는 재배치 레지스터(relocation register)라고도 부르며 그 프로세스의 물리적 메모리 시작 주소를 가지고 있다.
    
    
프로세스는 자신만의 고유한 주소 공간을 가지고 있으므로 동일한 주소값이라 하더라도 각 프로세스마다 서로 다른 내용을 담고 있게 되는데 MMU 기법이 이를 지원한다.


다중 프로그래밍 환경에서 물리적 메모리 안에 여러 개의 프로세스가 동시에 올라와 있는 경우가 대부분이다. MMU 기법을 사용하여 주소 변환을 했을 경우 CPU가 요청한 논리적 주소값과 재배치 레지스터 안에 있는 값을 더한 결과가 해당 프로세스의 주소 공간으 벗어나는 경우가 발생할 수 있다.
운영 체제는 이러한 특수한 상황이 발생하는 것을 방지하기 위해 한계 레지스터를 사용한다.
* 한계 레지스터는 현재 CPU에서 수행중인 프로세스의 논리적 주소의 최댓값(프로세스의 크기)을 담고 있다.


메모리 보안을 달성하는 방법:
1. CPU가 요청한 프로세스의 논리적 주소값이 한계 레지스터 내에 저장된 그 프로세스의 크기보다 작은지 확인
2. 작다면 논리적 주소값에 재배치 레지스터 값을 더해 물리적 주소를 구한 다음 해당 물리적 메모리 위치를 접근하도록 허락
3. 크다면 다른 프로세스의 주소 영역을 접근하려는 시도이므로 트랩을 발생시켜 해당 프로세스를 강제 종료



&nbsp;      
## 메모리 관리와 관련된 용어
### 동적 로딩 dynamic loding
여러 프로그램이 동시에 메모리에 올라가서 수행되는 다중 프로그래밍(multi-programming) 환경에서 메모리 사용의 효율성을 높이기 위해 사용하는 기법으로 프로세스가 시작될 때 그 프로세스의 주소 공간 전체를 메모리에 다 올려놓는 것이 아니라 메모리를 좀더 효율적으로 사용하기 위해 해당 루틴이 불려질 때 그 루틴만을 메모리에 적재하는 방식을 사용한다.


기존의 방식에 비해 같은 크기의 물리적 메모리에 더 많은 프로그램으 적재할 수 있기 때문에 메모리 이용의 효율성이 향상된다.


&nbsp;      
### 동적 연결 dynamic linking
컴파일을 통해 생성된 목적 파일(object file)과 라이브러리 파일(library file) 사이의 연결을 프로그램의 실행 시점까지 지연시키는 기법으로 실행 파일에 라이브러리 코드가 포함되지 않으며, 프로그램이 실행되면서 라이브러리 함수를 호출할 때가 되어서야 라이브러리에 대한 연결이 이루어진다.
* 라이브러리 루틴의 위치를 찾기 위한 스텁(stub)이 존재


다수의 프로그램이 공통으로 사용하는 라이브러리를 메모리에 한 번만 적재하므로 메모리 사용의 효율성을 높일 수 있다.


&nbsp;      
### 중첩 overlays
프로세스의 주소 공간을 분할해 실제 필요한 부분만을 적재하는 기법으로 프로그램의 크기가 물리적 메모리의 크기에 비해 작다면 주소 공간 전체를 한꺼번에 올리고 그렇지 않다면 분할해 메모리에 올린다. 


동적 로딩과 개념적으로 유사하지만 사용하는 이유는 상이하다. 동적 로딩은 메모리에 더 많은 프로세스를 동시에 올려놓고 실행하기 위한 용도인 반면 중첩은 단일 프로세스만 메모리에 올려놓는 환경에서 메모리 용량보다 큰 프로세스를 실행하기 위한 어쩔 수 없는 선택이다.


&nbsp;      
### 스와핑 swapping
메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역(swap area)에 일시적으로 내려놓는 것
* 스왑 인(swap in): 디스크에서 메모리로 올리는 작업
* 스왑 아웃(swap out): 메모리에서 디스크로 내리는 작업


스와핑이 일어나는 과정은 다음과 같다:
1. 스와핑은 스와퍼(swapper)에 의해 스왑 아웃시킬 프로세스를 선정한다.
2. 스왑 아웃 대상으로 선정된 프로세스에 대해서는 현재 메모리에 올라가 있는 주소 공간의 내용을 통째로 디스크 스왑 영역에 스왑 아웃시킨다.


스와핑의 가장 중요한 역할은 메모리에 존재하는 프로세스의 수를 조절할 수 있다는 점이다.


컴파일 타임 방식과 로드 타임 바인딩 방식에서는 스왑 아웃된 프로세스가 다시 스왑 인될 때에는 원래 존재하던 메모리 위치로 다시 올라가야 한다. 실행 시간 바인딩 기법에서는 추후 빈 메모리 영역 아무 곳에나 프로세스를 올릴 수 있다.


&nbsp;      
## 물리적 메모리의 할당 방식
물리적 메모리는 운영 체제 상주 영역과 사용자 프로세스 영역으로 나뉘어 사용된다.
* 운영 체제 상주 영역: 인터럽트 벡터와 함께 물리적 메모리의 낮은 주소 영역을 사용, 운영 체제 커널이 위치
* 사용자 프로세스 영역: 물리적 메모리의 높은 주소 영역을 사용, 여러 사용자 프로세스들이 적재되어 실행, 관리 방법은 프로세스를 메모리에 올리는 방식에 따라 나뉜다:
    * 연속 할당(contiguous allocation) 방식: 각각의 프로세스를 물리적 메모리의 연속적인 공간에 올리는 방식, 물리적 메모리를 다수의 분할로 나누어 하나의 분할에 하나의 프로세스가 적재되도록 한다. 분할을 관리하는 방식:
        * 고정 분할 방식(fixed partition allocation): 물리적 메모리를 고정된 크기의 분할로 미리 나누어 두는 방식
        * 가변 분할 방식(variable partition allocation): 분할을 미리 나누어 놓지 않고 프로그램이 실행되고 종료되는 순서에 따라 분할을 관리하는 방식
    * 불연속 할당(noncontiguous allocation) 방식: 하나의 프로세스를 물리적 메모리의 여러 영역에 분산해 적재하는 방식
        * 페이징(pagin) 기법: 각 프로세스의 주소 공간을 동일한 크기의 페이지로 잘라서 메모리에 페이지 단위로 적재
        * 세그먼테이션(segmentation) 기법: 프로그램의 주소 공간을 코드, 데이터, 스택 등 의미 있는 단위인 세그먼트로 나누어 세그먼트 단위로 적재
        * 페이지드 세그먼테이션(paged segmentation) 기법: 세그먼트 하나를 다수의 페이지로 구성


&nbsp;            
### 연속 할당 방식
프로세스를 메모리에 올릴 때 그 주소 공간을 여러 개로 분할하지 않고 물리적 메모리의 한 곳에 연속적으로 적재하는 방식


#### 고정 분할 방식
물리적 메모리를 주어진 개수만큼의 영구적인 분할(partition)로 미리 나누어 두고 각 분할에 하나의 프로세스를 적재해 실행, 하나의 분할에는 하나의 프로그램만을 적재할 수 있다. 따라서, 동시에 메모리에 올릴 수 있는 프로그램의 수가 고정되어 있으며 수행 가능한 프로그램의 최대 크기 또한 제한된다는 점에서 가변 분할 방식에 비해 융통성이 떨어진다. 외부 조각(external fragmentation)과 내부 조각(internal fragmentation)이 발생할 수 있다.
* 외부 조각: 프로그램의 크기보다 분할의 크기가 작은 경우 해당 분할이 비어 있는데도 불구하고 프로그램을 적재하지 못하기 때문에 발생하는 메모리 공간, 외부 조각보다 작은 크기의 프로그램이 실행된다면 외부 조각에 적재시킬 수 있다.
* 내부 조각: 프로그램의 크기보다 분할의 크기가 큰 경우 해당 분할에 프로그램을 적재하고 남는 메모리 공간, 특정 프로그램이 이미 배당된 공간이므로 내부 조각에 수용할 수 있는 작은 크기의 프로그램이 있다 해도 사용될 수 없어 메모리 공간의 낭비가 초래된다.


#### 가변 분할 방식
메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식, 프로그램의 크기를 고려해서 메모리를 할당하고 이를 기술적으로 관리할 수 있는 기법을 필요로 한다. 내부 조각은 발생하지 않지만 이미 메모리에 존재하는 프로그램이 종료될 경우 중간에 빈 공간이 발생하게 되며, 이 공간이 새롭게 시작되는 프로그램의 크기보다 작을 경우 외부 조각이 발생할 가능성이 있다.


* 동적 메모리 할당 문제(dynamic storage-allocation problem): 주소 공간의 크기가 n인 프로세스를 메모리에 올릴 때 물리적 메모리 내의 가용 공간 중 어떤 위치에 올릴 것인지를 결정하는 문제


동적 메모리 할당 문제를 해결하는 대표적인 방법:
1. 최초 적합(first-fit) 방법: 크기가 n 이상인 가용 공간 중 가장 먼저 찾아지는 곳에 프로세스를 할당, 시간적인 측면에서 효율적
2. 최적 적합(best-fit) 방법: 크기가 n 이상인 가장 작은 가용 공간을 찾아 그곳에 새로운 프로그램을 할당, 시간적 오버헤드가 발생하고 다수의 매우 작은 가용 공간들이 생성될 수 있다는 단점이 있지만 공간적인 측면에서 효율적
3. 최악 적합(worst-fit) 방법: 가용 공간 중에서 가장 크기가 큰 곳에 새로운 프로그램을 할당, 시간적 오버헤드 발생, 가용 공간을 빨리 소진한다는 문제점


컴팩션(compaction) 방법: 가변 분할 방식에서 발생하는 외부 조각 문제를 해결하기 위한 방법, 물리적 메모리 중에서 프로세스에 의해 사용중인 메모리 영역을 한쪽으로 몰고 가용 공간들을 다른 한쪽으로 모아서 하나의 큰 가용 공간을 만든다. 비용이 매우 많이 드는 작업이고 실행 시간 바인딩 방식이 지원되는 환경에서만 수행될 수 있다.


&nbsp;      
### 불연속 할당 방식
하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라갈 수 있는 메모리 할당 기법, 하나의 프로그램을 분할하는 기준에 따라 동일한 크기로 나누어 메모리에 올리는 페이징 기법, 크기는 일정하지 않지만 의미 단위로 나누어 메모리에 오릴는 세그먼테이션 기법, 세그먼테이션 내에서 동일한 크기의 페이지로 나누어 메모리에 올리는 페이지드 세그먼테이션 기법으로 분류할 수 있다.


&nbsp;      
## 페이징 기법
페이징(paging) 기법이란 프로세스의 주소 공간을 동일한 사이즈의 페이지 단위로 나누어 물리적 메모리에 불연속적으로 저장하는 방식이다. 각 프로세스의 주소 공간 전체를 물리적 메모리에 한꺼번에 올릴 필요가 없다. 페이징 기법에서는 물리적 메모리를 페이지 크기와 동일한 크기의 프레임(frame)으로 미리 나누어 두는데 이는 메모리에 올리는 단위가 동일한 크기의 페이지 단위이므로 메모리를 같은 크기로 미리 분할해 두더라도 빈 프레임이 있으면 어떤 위치이든 사용될 수 있기 때문이다. 동적 메모리 할당 문제가 발생하지 않는다는 장점이 있다.


연속 할당 방식에 비해 주소 변환 절차가 다소 복잡하다. 이는 하나의 프로세스라 하더라도 페이지 단위로 물리적 메모리에 올리는 위치가 상이하므로 논리적 주소를 물리적 주소로 변환하는 작업이 페이지 단위로 이루어져야 하기 때문이다. 따라서, 모든 프로세스가 각각의 주소 변환을 위한 페이지 테이블을 가지며, 이 테이블은 프로세스가 가질 수 있는 페이지의 개수만큼 주소 변환 엔트리를 가지고 있게 된다.


프로세스의 주소 공간과 물리적 메모리가 모두 같은 크기의 페이지 단위로 나누어지기 때문에 빈 공간은 어느 곳이든 활용 가능하다. 따라서, 외부 조각 문제가 발생하지 않는다. 그러나, 프로그램의 크기가 항상 페이지 크기의 배수가 된다는 보장이 없기 때문에 프로세스의 주소 공간 중 제일 마지막에 위치한 페이지에서는 내부 조각이 발생할 가능성이 있다.


&nbsp;      
### 주소 변환 기법
페이징 기법에서는 CPU가 사용하는 논리적 주소를 페이지 번호(p)와 페이지 오프셋(d)으로 나누어 주소 변환(address translation)에 사용한다. 페이지 번호는 페이지 테이블(page table)의 인덱스(index)로 사용 되고, 해당 인덱스의 항목(entry)에는 그 페이지의 물리적 메모리 상의 기준 주소(base address)가 저장된다.


페이지 오프셋은 하나의 페이지 내에서의 변위(displacement)를 알려 준다. 기준 주소값에 변위를 더함으로써 요청된 논리적 주소에 대응하는 물리적 주소를 얻을 수 있다.


&nbsp;      
### 페이지 테이블의 구현 
페이지 테이블은 페이징 기법에서 주소 변환을 하기 위한 자료 구조로 물리적 메모리에 위치한다. 현재 CPU에서 실행중인 프로세스의 페이지 테이블을 접근하기 위해 운영 체제는 두 개의 레지스터를 사용한다:
* 페이지 테이블 기준 레지스터(page-table base register): 메모리 내에서의 페이지 테이블의 시작 위치를 가리킨다.
* 페이지 테이블 길이 레지스터(page-table length register): 페이지 테이블의 크기를 보관한다.


페이징 기법에서 메모리를 한 번 접근하기 위해서는 매번 메모리를 두 번 접근해야 하는 오버헤드가 뒤따르는데 이를 줄이고 접근 메모리의 접근 속도를 향상시키기 위해 TLB(translation look-aside buffer)라고 불리는 고속의 주소 변환용 하드웨어 캐쉬가 사용되기도 한다.


TLB에는 빈번히 참조되는 페이지에 대한 주소 변환 정보만을 담는다. 따라서 요청되는 페이지에 대한 주소 변환 정보가 TLB 내에 존재할 수도 그렇지 않을 수도 있다. 존재하는 경우 곧바로 대응하는 물리적 메모리의 프레임 번호를 얻을 수 있지만, 존재하지 않는 경우 메모리에 있는 메모리에 있는 페이지 테이블로부터 프레임 번호를 알아내야 한다. 문맥 교환시 TLB 내용은 모두 지워야 한다.


TLB를 사용한 주소 변환의 경우 프로세스의 모든 페이지에 대한 주소 변환 정보를 가지고 있지 않기 때문에 페이지 번호와 이에 대응하는 프레임 번호가 쌍으로 저장되어야 한다. 또한 해당 페이지에 대한 주소 변환 정보가 TLB에 있는지를 확인하기 위해 모든 항목을 찾아봐야 하는 오버헤드가 발생한다. 이러한 오버헤드를 줄이기 위해 TLB의 구현에는 일반적으로 병렬 탐색(parallel search)이 가능한 연관 레지스터(associative resister)를 사용한다.


&nbsp;      
### 계층적 페이징
페이지 테이블에 사용되는 메모리 공간의 낭비를 줄이기 위해 2단계 페이징(two-level paging) 기법을 사용한다.


2단계 페이징 기법에서는 주소 변환을 위해 외부 페이지 테이블(outer page table)과 내부 페이지 테이블(inter page table)을 사용한다. 사용 되지 않는 주소 공간에 대해서는 외부 페이지 테이블의 항목을 NULL로 설정, 여기에 대응하는 내부 페이지 테이블을 생성하지 않으므로서 메모리의 낭비를 크게 줄일 수 있다. 하지만 주소 변환을 위해 접근해야 하는 페이지 테이블의 수가 증가하므로 시간적인 손해가 뒤따르게 된다.


2단계 페이징 기법에서는 프로세스의 논리적 주소를 두 종류의 페이지 번호(P1, P2)와 페이지 오프셋(d)으로 구분한다. 첫 번째 페이지 번호(P1)는 외부 페이지 테이블의 인덱스이고, 두 번째 페이지 번호(P2)는 내부 페이지 테이블의 인덱스이다.


프로세스의 주소 공간이 커질수록 페이지 테이블의 크기도 커지므로 주소 변환을 위한 메모리 공간 낭비도 더 심각해진다. 따라서, 다단계 페이지 테이블이 필요하게 된다. 다단계 페이지 테이블을 사용하면 메모리 공간의 소모는 줄일 수 있지만 그만큼 메모리에 대한 접근 횟수가 많아지기 때문에 메모리 접근 시간이 크게 늘어나는 문제가 발생할 수 있다.


메모리 접근에 의한 시간적인 오버헤드를 줄이기 위해서 TLB를 함께 사용하면 다단계 페이지 테이블로 인해 공간적인 이득을 얻을 수 있으면서 동시에 메모리 접근 시간도 그다지 늘어나지 않아 시간적인 효율성 또한 얻을 수 있게 된다.


&nbsp;      
### 역 페이지 테이블
역 페이지 테이블 기법은 물리적 메모리의 페이지 프레임 하나당 페이지 테이블에 하나의 항목을 두는 방식이다. 각 프로세스마다 페이지 테이블을 두는 것이 아니라 시스템 전체(system-wide)에 페이지 테이블을 하나만 두는 방법을 말한다. 페이지 테이블의 각 항목은 프로세스 번호(pid)와 그 프로세스 내의 논리적 페이지 번호(P)를 담고 있게 된다.


역 페이지 테이블은 물리적 주소로부터 논리적 주소를 얻기가 수월한 구조로 되어 있어서 주소 변환은 다소 비효율적인 측면이 있다. 주소를 담은 페이지가 물리적 메모리에 존재하는지의 여부를 판단하기 위해 페이지 테이블 전체를 다 탐색해야 하는데 이는 상당한 시간이 필요 하기 때문에 역 페이지 테이블은 일반적으로 메모리에 유지하는 대신 연관 레지스터에 보관해 테이블 전체 항목에 대한 병렬 탐색을 가능하게 함으로써 시간적인 효율성을 꾀하게 된다.


&nbsp;      
### 공유 페이지
공유 페이지(shared page)란 공유 코드를 담고 있는 페이지이다. 여러 프로세스에 의해 공유되는 페이지이므로 물리적 메모리에 하나만 적재되어 메모리를 좀더 효율적으로 사용할 수 있게 한다.
* 공유 코드(shared code): 메모리 공간의 효율ㅈ거인 사용을 위해 여러 프로세스에 의해 공통으로 사용될 수 있도록 작성된 코드


공유 페이지는 그 페이지를 공유하는 모든 프로세스의 주소 공간에서 동일한 페이지 번호를 가져야 한다.


대비되는 개념으로 사유 페이지(private page)가 있는데 이것은 각 프로세스들이 공유하지 않고 프로세스별로 독자적으로 사용하는 페이지를 말한다.


&nbsp;      
### 메모리 보호
페이지 테이블의 각 항목에는 주소 변환 정보뿐 아니라 메모리 보호를 위한 비트를 두고 있다.
* 보호 비트(protection bit): 각 페이지에 대해 '어떠한' 접근을 허용하느냐에 대한 정보가 저장된다. 읽기/쓰기/읽기전용 등의 접근 권한을 설정하는 데에 사용된다.
* 유효-무효 비트(valid-invalid bit): '유효'로 세팅되어 있으면 해당 메모리 프레임에 그 페이지가 존재함을 뜻하며 접근이 허용된다. '무효'로 세팅되어 있는 경우 프로세스가 그 주소 부분을 사용하지 않거나, 해당 페이지가 물리적 메모리에 올라와 있지 않고 스왑 영역에 존재해 해당 메모리 프레임에 접근 권한이 없음을 의미한다.


&nbsp;      
## 세그먼테이션
프로세스의 주소 공간을 의미 단위인 세그먼트(segment)로 나누어 물리적 메모리에 올리는 기법이다.


세그먼트는 특정 크기 단위가 아닌 의미를 가질 수 있는 논리적 단위(logical unit)로 나누었기 때문에 그 크기가 균일하지 않다. 페이징 기법과 유사하지만 프로그램을 의미 단위인 세그먼트로 나누어 관리하므로 크기가 균일하지 않은 세그먼트들을 메모리에 적재하는 부가적인 메모리 관리 오버헤드가 뒤따르게 된다.


세그먼테이션 기법에서는 논리적 주소가 <세그먼트 번호, 오프셋>으로 나뉘어 사용된다. 세그먼트 번호는 해당 논맂거 주소가 프로세스 주소 공간 내에서 몇 번째 세그먼트에 속하는지를, 오프셋은 그 세그먼트 내에서 얼마만큼 떨어져 있는 위치인지를 나타낸다.


세그먼트 테이블의 각 항목에는 물리적 메모리에서 그 세그먼트의 시작 위치를 나타내는 기준점(base)과 그 세그먼트의 길이를 담는 한계점(limit)을 가지고 있다. 세그먼테이션 기법에서는 세그먼트의 길이가 균일하지 않으므로 세그먼트의 위치 정보뿐 아니라 길이 정보를 함께 보관하고 있는 것이다.


세그먼트 테이블 기준 레지스터(segment-table base register: STBR): 현재 CPU에서 실행중인 프로세스의 세그먼트 테이블이 메모리의 어느 위치에 있는지 그 시작 주소를 담고 있다.


세그먼트 테이블 길이 레지스터(segment-table length register: STLR): 프로세스의 주소 공간이 총 몇개의 세그먼트로 구성되는지, 세그먼트의 개수를 나타낸다.


논리적 주소를 물리적 주소로 변환하기 전에 두 가지 사항을 먼저 확인한다:
1. 요청된 세그먼트 번호가 세그먼트 테이블 길이 레지스터에 저장된 값보다 작은 값인가, 만약 그렇지 않다면 존재하지 않는 세그먼트에 대한 접근 시도이므로 예외 상황을 발생시켜 메모리 접근을 봉쇄시킨다.
2. 논리적 주소의 오프셋 값이 그 세그먼트의 길이보다 작은 값인가, 만약 그렇지 않다면 세그먼트 길이를 넘어서는 오프셋 위치에 대한 접근 시도이므로 예외 상황을 발생시켜 메모리 접근을 봉쇄시킨다.


위 두 가지 사항을 모두 만족하는 경우에 한해서, 유효한 메모리 접근 요청으로 판단해 주소 변환 작업이 이루어진다.


세그먼테이션 기법에서도 세그먼트 테이블의 각 항목에 각 세그먼트에 대해 읽기/쓰기/실행 등의 권한이 있는지를 나타내는 보호 비트와 해당 세그먼트가 현재 물리적 메모리에 적재되어 있는지를 나타내는 유효-무효 비트를 둔다. 여러 프로세스가 특정 세그먼트롤 공유해서 사용하는 공유 세그먼트(shared segment) 개념도 지원한다. 이 세그먼트는 모든 프로세스의 주소 공간에서 동일한 논리적 주소에 위치해야 한다.


세그먼트는 공유와 보안의 측면에서 페이징 기법에 비해 훨씬 효과적이다. 주소 공간의 일부를 공유하거나 특정 주소 공간에 읽기 전용 등의 접근 권한 제어를 하고자 할 경우 이는 어떤 의미 있는 단위로 이루어지지 단순히 크기 단위로 수행하는 일이 아니기 때문이다.


세그먼트의 길이가 균일하지 않아 물맂거 메모리 관리에서 외부 조각이 발생, 세그먼트를 어느 가용 공간에 할당할 것인지를 결정하는 문제가 발생한다. 가용 공간 할당 방식에는 최초 적합 방식과 최적 적합 방식이 있다.


&nbsp;
## 페이지드 세그먼테이션
페이징 기법과 세그먼테이션 기법의 장점만을 취하는 주소 변환 기법이다. 이 기법은 세그먼테이션 기법과 마찬가지로 프로그램을 의미 단위의 세그먼트로 나누게 된다. 단, 세그먼트가 임의의 길이를 가질 수 있는 것이 아니라 반드시 동일한 크기의 페이지들의 집합으로 구성되어야 한다. 그리고 물리적 메모리에 적재하는 단위는 페이지 단위로 한다.


세그먼테이션 기법에서 발생하는 외부 조각의 문제점을 해결하며, 접근 권한 보호가 이루어지게 함으로써 페이징 기법의 약점을 해소한다.


주소 변환을 위해 외부의 세그먼트 테이블과 내부의 페이지 테이블을 이용한다(2단계 페이지 테이블과 유사한 구조).


&nbsp;
&nbsp;      
### [by. 0junChoi](https://github.com/0jun0815) email: <0jun0815@gamil.com>

