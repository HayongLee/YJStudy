# 컴퓨터 시스템의 동작 원리


* [컴퓨터 시스템의 구조](#컴퓨터-시스템의-구조)
* [CPU와 I/O 연산](#cpu와-i/o-연산)
* [인터럽트의 일반적 기능](#인터럽트의-일반적-기능)
* [인터럽트 핸들링](#인터럽트-핸들링)
* [입출력 구조](#입출력-구조)
    * [동기식 입출력](#동기식-입출력)
    * [비동기식 입출력](#비동기식-입출력)
* [DMA(Direct Memory Access)](#dmadirect-memory-access)
* [저장 장치의 구조](#저장-장치의-구조)
* [저장 장치의 계층 구조](#저장-장치의-계층-구조)
* [하드웨어의 보안](#하드웨어의-보안)
* [메모리 보안](#메모리-보안)
* [CPU 보호](#cpu-보호)
* [시스템 콜을 이용한 입출력 수행](#시스템-콜을-이용한-입출력-수행)


&nbsp;
## 컴퓨터 시스템의 구조
컴퓨터 시스템의 구조는 내부 장치인 CPU, 메모리와 외부 장치인 디스크, 키보드, 마우스, 모니터, 네트워크 장치 등으로 구분된다. 컴퓨터의 업무 처리 방식은 외부 장치에서 컴퓨터 내부로 데이터를 읽어와서 각종 연산을 수행한 후 그 결과를 외부 장치로 다시 내보내는 방식으로 진행된다. 컴퓨터 내부로 데이터가 들어오는 것을 입력(input), 외부 장치로 데이터가 나가는 것을 출력(output)이라고 한다.


컨트롤러는 각 하드웨어 장치마다 존재하면서 이들을 제어하는 작은 CPU라 할 수 있다.


운영 체제는 컴퓨터가 부팅되었을 때부터 항상 수행되면서 각종 자원들을 관리해야 하므로 항상 메모리에 올라가 있다. 운영 체제 중 항상 메모리에 올라가 있는 부분은 전체 운영 체제 중 일부분에 해당하는데, 이를 커널(kernel)이라 한다.


![컴퓨터 시스템 구조](https://github.com/0jun0815/YJStudy/blob/master/운영체제/컴퓨터%20시스템의%20동작%20원리/images/compuer-system-architecture.png)


&nbsp;
## CPU와 I/O 연산
입출력 장치들의 I/O 연산은 I/O 컨트롤러가 담당하고, 컴퓨터 내에서 수행되는 연산은 메인 CPU가 담당한다. 입출력 장치와 메인  CPU는 동시 수행이 가능하다. 장치 컨트롤러에는 장치로부터 들어오고 나가는 데이터를 임시로 저장하기 위한 작은 메모리인 로컬 버퍼(local buffer)를 가지고 있다.


디스크나 키보드 등에서 데이터를 읽어오는 경우, 우선 로컬 버퍼에 데이터가 임시로 저장된 후 메모리에 전달된다. 이때, 장치에서 로컬 버퍼로 읽어오는 일은 컨트롤러가 담당한다. 데이터를 모두 가지고 왔는지 확인하는 작업은 메인 CPU가 일일이 체크하는 것이 아니라 장치에 있는 컨트롤러가 인터럽트를 발생시켜 CPU에게 보고한다. 인터럽트란 컨트롤러들이 CPU의 서비스가 필요할 때 이를 CPU 옆에 있는 인터럽트 라인(interrupt line)으로 신호를 주어 통보하는 방법이다. CPU는 명령 하나를 수행할 때마다 인터럽트가 발생했는지를 체크한다. 인터럽트가 발생했으면 다음 명령을 수행하기 전에 인터럽트 처리를 하게 되고 그렇지 않으면 다음 명령을 계속 수행하게 된다. 인터럽트는 키보드 입력 혹은 디스크에서 데이터를 다 읽어왔다는 등의 이벤트를 CPU에게 알려 줄 필요가 있는 경우 컨트롤러가 발생시키는 것이다.


&nbsp;
## 인터럽트의 일반적 기능
운영 체제는 각종 하드웨어, 소프트웨어 자원 관리뿐 아니라 사용자 프로그램에게 필요한 서비스도 제공한다. 운영 체제가 해야 할 일들을 운영 체제의 개발자가 미리 프로그래밍을 해서 커널 내에 포함하는데 그중 한 가지가 인터럽트 처리 루틴이다. 운영 체제 커널 내에 있는 인터럽트 처리 루틴은 다양한 인터럽트에 대해 각각 처리해야 할 업무들을 정의하고 있다.  예를 들어, 디스크 컨트롤러가 인터럽트를 발생시키면 CPU는 하던 일을 잠시 멈추고 이 인터럽트가 발생했을 때 수행해야 할 코드 영역으로 가서 정의된 일을 수행하게 된다.


인터럽트에는 하드웨어 인터럽트와 소프트웨어 인터럽트가 있다. CPU의 서비스가 필요한 경우, CPU 옆에 있는 인터럽트 라인에 신호를 보내어서 인터럽트가 발생했음을 알려 주는 방식은 둘 다 동일하다. 다만, 하드웨어 인터럽트는 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅하는 반면 소프트웨어 인터럽트는 소프트웨어가 그 일을 수행한다는 차이점이 있다. 어떤 인터럽트이든 일단 발생하면 CPU는 하던 일을 멈추고 인터럽트를 처리하기 위한 루틴(운영 체제 커널 내부 코드)에 들어가서 정의된 일을 찾게 된다. 운영 체제는 할 일을 쉽게 찾아가기 위해 인터럽트 벡터(interrupt vector)를 가지고 있다. 인터럽트 벡터란 인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야 할 코드가 위치한 부분을 포인터로 가리키고 있는 자료 구조이다.


인터럽트 서비스 루틴을 통해 해당하는 인터럽트 처리를 완료하고 나면 원래 수행하던 작업으로 돌아가 정지되었던 일을 계속해서 수행한다. 인터럽트 처리 후 되돌아갈 위치를 알아야 하므로 인터럽트 처리 전에 수행 중이던 작업이 무엇이었는지 반드시 저장해 두어야 한다.


프로그램은 코드(code), 데이터(data), 스택(stack) 등의 영역으로 나뉜다.
* 스택이란 실행 중인 함수에서 다른 함수를 호출한 경우 호출된 함수의 종료 후 원래 함수의 실행 중이던 위치로 돌아가기 위해 복귀 주소를 저장하는 영역이다.
* 데이터 영역은 전역 변수 등 프로그램이 사용하는 각종 데이터가 저장되는 공간이다.
* 코드 부분은 프로그래머가 작성한 코드가 기계어 명령(machine instruction) 형태로 저장되는 영역이다. CPU는 매 시점 코드 부분에 있는 명령을 하나씩 읽어와서 수행한다.


&nbsp;
## 인터럽트 핸들링
인터럽트 핸들링(interrupt handling)이란 인터럽트가 발생한 경우에 처리해야 할 일의 절차를 의미한다. CPU에서 명령이 수행될 때에는 레지스터(register)에 데이터를 읽어오거나 쓰면서 작업을 수행하게 되는데, 인터럽트가 발생해 새로운 명령을 수행하면 기존의 레지스터 값들이 지워지게 되므로 레지스터 값 등  CPU 내의 하드웨어 상태를 저장해 두어야 한다. 이것을 모두 저장한 후에야 인터럽트 처리가 이루어질 수 있다.


운영 체제 커널 영역에는 현재 시스템 내에서 수행되는 프로그램들을 관리하기 위한 자료 구조인 프로세스 제어 블록(PCB : Process Control Block)을 두고 있다. PCB 중 일부분은 인터럽트가 발생했을 때 프로그램의 어느 부분이 수행되던 중이었는지를 저장하기 위한 자료 구조로 사용된다. 저장되는 내용으로는 메모리 주소와 레지스터 값, 하드웨어 상태 등이 있다. 인터럽트 수행이 끝나면 저장된 값을 CPU 상에 다시 복원해 인터럽트 당하기 직전의 명령을 계속 수행한다.


인터럽트 처리 루틴은 운영 체제 커널 프로그램 중 일부이고 커널 역시 함수 구조이므로 인터럽트 처리 코드가 수행되는 도중에도 함수 호출이 이루어질 수 있어 스택의 이용이 필요하다. 인터럽트 처리 중 발생하는 함수 호출시에는 운영 체제 커널의 주소 공간 중 스택 영역을 사용한다.


현재 수행 중인 프로그램의 수가 n 개라고 할 때 커널 스택은 현재 수행 중인 프로그램의 개수인 n 만큼 독립적인 공간을 둔다. 인터럽트 처리 루틴으로 넘어와서 함수 호출이 이루어질 경우에는 각 프로세스별로 독자적인 커널 스택을 사용하게 된다.


인터럽트 처리 중에 또 다른 인터럽트가 발생하는 경우에 어떻게 처리가 될까? 
* 원칙적으로는 허용하지 않는다. 인터럽트 처리 중에 다른 인터럽트를 처리하게 되면 데이터의 일관성이 유지되지 않는 경우가 발생할 수 있기 때문이다.


그렇지만 경우에 따라 예외가 존재한다:
* 인터럽트마다 중요도가 다르기 때문에 상대적으로 낮은 중요도를 가진 인터럽트 작업 수행 중에 중요도가 더 높은 인터럽트가 발생하는 것을 허락한다. 현재 처리 중인 인터럽트보다 더 높은 우선순위의 인터럽트가 발생한다면 현재 처리 중이던 인터럽트 코드의 수행 지점을 커널 스택에 저장하고 우선순위가 높은 인터럽트를 처리하게 된다. 인터럽트 처리가 마쳐지면 커널 스택에 저장된 주소로 복귀해 이전에 수행하던 인터럽트 처리 코드를 마저 수행한다.


통상적으로 인터럽트라고 하면 하드웨어 인터럽트를 의미하고, 소프트웨어 인터럽트는 트랩(trap)이라는 용어로 주로 불린다. 소프트웨어 인터럽트의 예로는 예외 상황(exception), 시스템 콜(system call) 등이 있다.
* 예외 상황이란 프로세스가 0으로 나누는 연산 등 불가능한 작업을 시도하거나, 자신의 메모리 영역 바깥을 접근하려는 시도를 할 때 이에 대한 처리를 위해 발생시키는 인터럽트이다.


하드웨어 인터럽트란 각종 하드웨어 장치들이 CPU에게 서비스를 받아야 하는 경우에 발생, 인터럽트 라인을 통해 CPU에게 전달된다.


소프트웨어 인터럽트는 컨트롤러가 발생시키는 인터럽트가 아니라 프로그램 수행 도중 직접 CPU에 인터럽트 라인을 세팅하여 발생시키게 된다. 소프트웨어 인터럽트가 발생하면 현재까지의 수행 지점을 저장, 인터럽트 처리 루틴으로 가서 인터럽트 발생과 관련한 작업을 수행, 다시 인터럽트 당한 지점으로 돌아와 프로그램을 계속 실행하게 된다.


넓은 의미로는 하드웨어 인터럽트 및 소프트웨어 인터럽트를 합쳐 인터럽트라고 말하기도 한다.


운영 체제는 인터럽트 발생 시에만 수행된다. CPU가 항상 사용자 프로그램에 의해 사용되며 운영 체제는 단지 인터럽트 발생 시에만 잠깐 CPU의 제어권을 획득할 수 있기 때문이다. 인터럽트가 발생하지 않으면 원래 수행 중인 사용자 프로세스가 원하는 만큼 CPU를 계속 점유한다.


&nbsp;
## 입출력 구조
입출력(I/O)이란 컴퓨터 시스템이 컴퓨터 외부의 주변 장치들과 데이터를 주고받는 것. 입출력 방식에는 동기식 입출력과 비동기식 입출력이 있다.


### 동기식 입출력
동기식 입출력(synchronous I/O)은 입출력 요청 후 입출력 작업이 완료된 후에야 CPU의 제어권이 그 프로그램에게 다시 넘어갈 수 있는 방식이다. 동기식 입출력에서는 입출력 연산이 끝날 때까지 CPU는 아무 일을 수행할 수 없기 때문에 자원의 낭비가 초래된다. 따라서 일반적으로 프로그램이 입출력을 수행 중인 경우 CPU를 다른 프로그램에게 이양해 CPU가 계속 쉬지 않고 일할 수 있도록 관리해야 한다. 봉쇄 상태(입출력 완료 시까지 CPU 할당 x)의 프로그램에게는 CPU를 할당하지 않고, CPU를 할당하면 곧바로 작업을 수행할 수 있는 프로그램들에게만 CPU를 할당한다.


동기식 입출력을 수행 중일 때 다른 프로그램에게 CPU를 양도하게 되므로 다수의 입출력 연산이 동시에 요청되거나 처리될 수 있는데 이때 의도하지 않은 결과를 초래할 수도 있다. 따라서, 동기식 입출력에서는 입출력 요청의 동기화를 위해 장치별로 큐(queue)를 두어 요청한 순서대로 처리할 수 있도록 한다.


장치마다 큐 헤더가 존재하고 각 장치별로 입출력 수행 순서를 지켜 주기 위한 큐를 관리하고 있다. 컨트롤러는 이 순서에 따라 입출력 작업을 처리하는데 CPU의 수행 속도에 비해 컨트롤러의 수행 속도나 장치 자체의 작업 수행 능력은 매우 떨어진다. 그렇기 때문에 입출력이 완료될 때까지 CPU가 입출력과 관련 없는 프로그램을 수행하도록 하고, 요청된 입출력 연산이 완료되면 CPU에게 입출력이 완료되었음을 알려 주는 방식으로 진행된다. 연산 완료의 통보는 인터럽트를 통해서 수행, 운영 체제 커널은 인터럽트 처리 루틴으로 가서 입출력 연산을 끝낸 프로그램이 CPU를 할당받을 수 있도록 그 프로그램의 상태를 봉쇄 상태로부터 해제시킨다.


### 비동기식 입출력
비동기식 입출력(asynchronous I/O)은 입출력 연산을 요청한 후에 연산이 끝나기를 기다리는 것이 아니라 CPU의 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여하는 방식이다.


데이터를 디스크에서 읽어오라는 요청을 했을 때 데이터와 관련 없이 수행할 수 있는 일을 먼저 수행, 읽어오는 데이터가 반드시 있어야 수행할 수 있는 일들은 입출력이 완료된 후에 수행하게 된다. 디스크에 쓰는 요청이라면 쓰기 작업이 완료되기 전에도 다음 명령을 수행할 수 있으므로 비동기식 입출력이 사용될 수 있다.


비동기식 입출력에서도 입출력 연산이 완료되면 동기식과 마찬가지로 인터럽트를 통해 이를 CPU에게 알려 주게 된다. 그러면 그 시점부터 읽어온 데이터를 필요로 하는 명령을 수행할 수 있게 된다.


일반적으로는 입출력 요청을 운영 체제에게 하게 되면 해당 프로그램의 입출력이 완료될 때까지 그 프로그램을 봉쇄시키는 동기식 입출력을 사용한다. 이때 운영 체제는 장치별로 입출력 처리를 기다리는 프로세스를 줄 세워 관리함으로써 동기성을 보장하게 되는 것이다.


&nbsp;
## DMA(Direct Memory Access)
원칙적으로 메모리는 CPU에 의해서만 접근 가능한 장치이다. 모든 메모리 접근 연산이 CPU에 의해서만 이루어질 경우 주변 장치가 메모리 접근을 원할 때마다 인터럽트를 통해 CPU의 업무가 방해를 받게 되어 CPU 사용의 효율성이 떨어지는 문제점이 발생하게 된다. 이러한 비효율성을 극복하기 위해 CPU 이외에 메모리 접근이 가능한 장치인 DMA를 둔다.


DMA는 일종의 컨트롤러로서, CPU가 주변 장치들의 메모리 접근 요청에 의해 자주 인터럽트 당하는 것을 막아주는 역할을 한다.


DMA를 사용하게 되면 로컬 버퍼에서 메모리로 읽어오는 작업을 CPU가 담당하는 것이 아니라, DMA가 대행함으로써 CPU는 원래 하던 작업을 멈추고 인터럽트를 처리할 필요가 없어진다. DMA는 바이트(byte) 단위가 아니라 블록(block)이라는 큰 단위로 정보를 메모리로 읽어온 후에 CPU에게 인터럽트를 발생시켜서 해당 작업의 완료를 알려 주게 된다.


&nbsp;
## 저장 장치의 구조
컴퓨터 시스템을 구성하는 저장 장치는 주 기억 장치와 보조 기억 장치로 나뉜다.
* 주 기억 장치는 보통 메모리라 부르며 전원이 나가면 저장되었던 내용이 모두 사라져 버리는 휘발성(volatile)의 RAM을 매체로 사용하는 경우가 대부분이다.
* 보조 기억 장치는 전원이 나가도 저장된 내용을 기억할 수 있는 비휘발성(nonvolatile)의 마그네틱 디스크, 플래시 메모리, CD, 마그네틱 테이프 등이 사용된다.


보조 기억 장치의 용도는 크게 두 가지로 구분된다.
* 첫째는 파일 시스템(file system) 용이다. 전원이 나가도 유지해야 할 정보가 있으면 그것을 파일 형태로 보조 기억 장치에 저장하게 된다.
* 두 번째 용도는 메모리의 연장 공간인 스왑 영역(swap area) 용이다. 메모리 공간이 부족할 경우 운영 체제는 프로그램 수행에 당장 필요한 부분만 메모리에 올려놓고 그렇지 않은 부분은 디스크의 스왑 영역에 내려놓게(스왑 아웃) 된다. 스압 아웃된 부분이 필요할 때에는 다시 메모리 영역으로 올리게 된다.
    * 스왑 영역으로는 하드 디스크가 가장 널리 사용.
    * 스왑 영역은 프로그램이 실행될 때 내용을 저장했다가 프로그램이 종료될 때 삭제하는 메모리의 연장 공간으로서의 역할을 담당하므로 파일 시스템처럼 비휘발성 용도로 사용되는 것과는 역할이 구분된다.


&nbsp;
## 저장 장치의 계층 구조
컴퓨터 시스템을 구성하는 저장 장치는 빠른 저장 장치부터 느린 저장 장치까지 단계적인 계층 구조로 이루어진다. 빠른 저장 장치는 단위 공간당 가격이 높기 때문에 적은 용량을 사용, 느린 저장 장치는 가격이 저렴해 대용량을 사용하는 반면 속도가 느리다는 약점이 있다. 따라서, 당장 필요한 정보는 빠른 저장 장치에 넣어 두어 수행 속도를 높이고 그렇지 않은 정보는 상대적으로 느린 저장 장치에 보관하게 된다.


![저장장치 계층 구조](https://github.com/0jun0815/YJStudy/blob/master/운영체제/컴퓨터%20시스템의%20동작%20원리/images/저장장치-계층-구조.png)


저장 장치의 계층은 최상위의 CPU 내부에 존재하는 레지스터(register)부터 캐시 메모리(cache memory), 메인 메모리 등의 휘발성 저장 장치로 구성되고 메인 메모리보다 아랫부분을 구성하는 저장 장치 계층은 전원이 나가도 지워지지 않는 비휘발성 저장 장치이다.


상위 저장 장치 계층으로 갈수록 접근 속도가 월등히 빠르지만 용량은 상대적으로 적다. 하지만, 당장 필요한 정보만을 선별적으로 저장하게 되면 마치 하위에 있는 큰 용량의 저장 장치를 가지고 있는 것과 비슷한 성능 효과를 낼 수 있다. 예를 들면 캐싱 기법을 이용해 적은 용량의 캐시 메모리를 사용해서도 메인 메모리와 같이 큰 용량을 가진 것처럼 효율적으로 동작하도록 관리할 수 있다.
* 캐싱 기법이란 캐시 메모리뿐 아니라 상대적으로 용량이 작은 빠른 저장 장치의 성능 향상을 위한 총체적 기법으로 상대적으로 느린 저장 장치에 있는 내용 중에 당장 사용되거나 빈번히 사용될 정보를 빠른 저장 장치에 선별적으로 저장해 두 저장 장치 사이의 속도를 완충시키는 기법을 의미한다.
* 빠른 저장 장치에 빈번히 사용될 정보를 저장하면 필요한 정보를 빠른 저장 장치에서 곧바로 찾을 수 있는 경우가 많아져 전체적인 성능이 향상된다.
* 캐싱 기법이 적은 용량으로도 효과를 거둘 수 있는 것은 컴퓨터 내의 데이터나 프로그램을 구성하는 모든 부분이 균일하게 참조되는 것이 아니라 일부분만이 집중적으로 참조되고 어떠한 부분은 거의 참조되지 않기 때문이다.


&nbsp;
## 하드웨어의 보안
운영 체제는 다중 프로그래밍(multi-programming) 환경에서 동작한다. 그러므로 각 프로그램들이 다른 프로그램의 실행을 방해하거나 프로그램 간에 서로 충돌을 일으키는 문제를 막기 위해 하드웨어에 대한 각종 보안 기법이 필요하다. 하드웨어적인 보안을 유지하기 위해서 운영 체제는 기본적으로 커널 모드(kernel mode, system mode)와 사용자 모드(user mode) 오퍼레이션(operation)을 지원한다.
* 커널 모드는 운영 체제가 CPU의 제어권을 가지고 운영 체제 코드를 실행하는 모드로서, 모든 종류의 명령을 다 실행할 수 있다.
* 사용자 모드에서는 일반 사용자 프로그램이 실행되며 제한적인 명령만을 수행할 수 있다.


시스템에 중요한 영향을 미치는 연산은 커널 모드에서만 실행 가능하도록 함으로써 하드웨어의 보안을 유지하는 것이다.


컴퓨터 시스템은 CPU 내부에 모드 비트(mode bit)를 두어 사용자 프로그램을 감시한다. 모드 비트 0은 커널 모드, 모드 비트 1은 사용자 모드이다.


CPU는 보안과 관련된 명령을 수행하기 전에는 항상 모드 비트를 조사해 모드 비트가 0으로 세팅된 경우에만 그 명령을 수행한다. 
1. 운영 체제가 CPU를 점유해 자신의 코드를 수행하다가 사용자 프로그램에게 CPU의 제어권을 넘길 때 모드 비트를 1로 세팅해 넘기게 된다. 
2. 사용자 프로그램이 수행되다가 하드웨어 접근 등 보안이 필요한 중요한 명령을 수행해야 할 경우에는 시스템 콜을 통해 운영 체제에게 서비스를 대신해 줄 것을 요청하면 CPU의 제어권은 다시 운영 체제로 넘어가게 된다. 인터럽트가 발생할 때에는 모드 비트가 자동적으로 0으로 세팅되어 운영 체제는 서비스에 필요한 모든 종류의 명령을 다 수행할 수 있다. 
3. 요청된 작업이 모두 끝난 후에는 모드 비트를 다시 1로 만들어 사용자 프로그램에게 CPU를 넘겨 주게 된다.


시스템의 보안과 관련된 명령들을 특권 명령이라 지칭하며, 특권 명령은 모드 비트가 0일 때에만 수행할 수 있다.


모든 입출력 명령은 특권 명령으로 규정해서 사용자 프로그램이 직접 입출력을 하는 것을 차단한다. 입출력이 필요할 때에는 시스템 콜로 운영 체제에게 서비스를 요청, 운영체제가 CPU를 할당받고 인터럽트 벡터의 특정 위치를 통해 해당 인터럽트 서비스 루틴으로 이동, 이때 인터럽트 하드웨어에 의해 모드 비트가 0으로 세팅되어 운영 체제는 입출력을 수행, 요청된 입출력이 완료되면 CPU의 제어권을 다시 사용자 프로그램에게 넘기고 사용자 프로그램은 시스템 콜 이후의 명령을 수행한다.


&nbsp;
## 메모리 보안
여러 프로그램이 메모리에 동시에 올라가서 실행되기 때문에 하나의 사용자 프로그램이 다른 사용자 프로그램이나 운영 체제가 위치한 메모리 영역을 침범할 수 있어 메모리도 보안이 필요하다. 기준 레지스터(base register)와 한계 레지스터(limit register)를 사용해서 프로그램이 접근하려는 메모리 부분이 합법적인지를 체크함으로써 메모리 보호가 이루어진다.
* 기준 레지스터는 어떤 프로그램이 수행되는 동안 그 프로그램이 합법적으로 접근할 수 있는 메모리 상의 가장 작은 주소를 보관하고 있다.
* 한계 레지스터는 그 프로그램이 기준 레지스터 값부터 접근할 수 있는 메모리의 범위를 보관하고 있다.


1. 어떤 프로그램이 실제 메모리에 올라가 있는 부분의 시작 주소와 그 프로그램의 길이를 각각 기준 레지스터와 한계 레지스터에 보관해 메모리 접근 연산이 있을 때마다 하드웨어적으로 현재 접근하려는 위치가 합법적인 범위인지를 체크하게 된다.
2. 사용자 프로그램은 기준 레지스터에 있는 주소부터 기준 레지스터 + 한계 레지스터 값 사이의 주소 영역만 접근이 가능하며 접근하려는 주소가 이 범위 안에 없으면 불법적인 메모리 접근이므로 예외 상황 인터럽트가 발생하게 된다.
3. 예외 상황은 운영 체제에게 소프트웨어적인 인터럽트를 발생시켜 CPU의 제어권을 해당 프로그램으로부터 운영 체제로 이양시키고 운영 체제는 예외 상황을 발생시킨 프로그램을 강제로 종료시킨다.


메모리 접근 연산은 사용자 프로그램이 CPU를 가지고 있는 동안에도 수행할 수 있는 연산이므로 특권 명령은 아니다. 다만, 사용자 프로그램이 메모리를 접근하기 전에 하드웨어적으로 그 접근이 합법적인지를 체크하여 메모리를 보호하게 된다. 사용자 모드인 경우에는 기준 레지스터와 한계 레지스터를 사용해서 메모리를 보호하게 되고, 커널 모드에서는 메모리에 무제한으로 접근이 가능하다. 


메모리 접근 명령은 특권 명령은 아니지만, 올바르지 않은 접근 시도로부터 메모리를 보호하기 위해서는 기준 레지스터와 한계 레지스터의 값을 세팅하는 연산은 특권 명령으로 규정해야 한다. 그러므로 운영 체제가 두 개의 레지스터 값을 직접 세팅해 주고 사용자 프로그램은 값을 변경할 수 없게 한다.


&nbsp;
## CPU 보호
CPU가 하나의 프로그램에 의해 독점되는 것을 막기 위해 운영 체제는 타이머(timer)라는 하드웨어를 사용한다. 타이머는 정해진 시간이 지나면 인터럽트를 발생시켜 운영 체제에게 CPU의 제어권을 이양시키는 역할을 수행한다.
* 타이머에 의해 발생되는 인터럽트 처리 루틴의 내용은 지금 CPU를 할당받고 수행 중인 프로그램에게서 CPU를 선점해 다른 프로그램에게 CPU를 이양하는 내용이다. 
* 타이머는 일정한 시간 단위로 세팅될 수 있으며 매 클럭 틱 때마다 1씩 감소, 0이 되는 순간에 인터럽트가 발생하게 된다.
* 타이머는 시분할 시스템(time sharing system)에서 현재 시간을 계산하기 위해서도 널리 사용된다.
* 타이머의 값을 세팅하는 명령을 로드 타이머(load timer)라 하며, 이는 특권 명령에 해당된다.


&nbsp;
## 시스템 콜을 이용한 입출력 수행
시스템 콜은 일종의 소프트웨어적인 인터럽트로서 사용자 프로그램이 시스템 콜을 할 경우 트랩이 발생해 CPU에 대한 제어권이 운영 체제로 넘어가게 된다. 그러면 운영 체제는 해당 시스템 콜을 처리하기 위한 루틴으로 가서 정의된 명령을 수행하게 된다. 시스템 콜이 디스크에 대한 입출력 요청이었으면 디스크 컨트롤러에게 입출력 요청을 수행하도록 명령하고, 수행을 마치면 CPU에게 인터럽트를 발생시켜 입출력이 완료되었음을 알려 주어 해당 프로그램이 다시 CPU를 할당받을 수 있도록 한다.


&nbsp;      
### [by. 0junChoi](https://github.com/0jun0815) email: <0jun0815@gmail.com>
### 출처: [운영 체제와 정보 기술의 원리](http://book.naver.com/bookdb/book_detail.nhn?bid=4392911), [반효경 운영체제 강의](http://www.kocw.net/home/search/kemView.do?kemId=1046323)

