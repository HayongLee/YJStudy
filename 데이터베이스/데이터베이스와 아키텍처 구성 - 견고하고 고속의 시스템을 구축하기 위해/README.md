# 데이터베이스와 아키텍처 구성 - 견고하고 고속의 시스템을 구축하기 위해


* [아키텍처란](#아키텍처란)
    * [아키텍처 설계의 필요성](#아키텍처-설계의-필요성)
    * [아키텍처 설계의 중요성](#아키텍처-설계의-중요성)
* [데이터베이스의 아키텍처 1. 역사와 개요](#데이터베이스의-아키텍처-1-역사와-개요)
    * [아키텍처의 역사](#아키텍처의-역사)
    * [Stand-alone의 특징](#stand-alone의-특징)
    * [Stand-alone의 단점](#stand-alone의-단점)
    * [Stand-alone의 장점](#stand-alone의-장점)
    * [클라이언트/서버 특징](#클라이언트/서버-특징)
    * [클라이언트/서버의 확장](#클라이언트/서버의-확장)
    * [클라이언트/서버 구성의 단점](#클라이언트/서버-구성의-단점)
    * [관리비용 문제란](#관리비용-문제란)
    * [웹 서버 계층과 애플리케이션 계층](#웹-서버-계층과-애플리케이션-계층)
* [데이터베이스의 아키텍처 2. 가용성과 확장성의 확보](#데이터베이스의-아키텍처-2-가용성과-확장성의-확보)
    * [가용성과 확장성을 확보하기 위해](#가용성과-확장성을-확보하기-위해)
    * [가용성을 높이는 2가지 전략](#가용성을-높이는-2가지-전략)
    * [클러스터란](#클러스터란)
    * [단일 장애점이란](#단일-장애점이란)
* [DB 서버의 다중화 - 클러스터링](#db-서버의-다중화-클러스터링)
    * [DB 서버의 다중화](#db-서버의-다중화)
    * [DB와 다른 서버의 차이](#db와-다른-서버의-차이)
    * [가장 기본적인 다중화](#가장-기본적인-다중화)
    * [Active-Active 구성의 장점](#active-active-구성의-장점)
    * [Active-Standby 구성의 종류](#active-standby-구성의-종류)
* [DB 서버와 데이터의 다중화 - 리플리케이션](#db-서버와-데이터의-다중화-리플리케이션)
    * [리플리케이션이란](#리플리케이션이란)
    * [리플리케이션에서 주의할 점](#리플리케이션에서-주의할-점)
    * [성능을 추구하기 위한 다중화 - Shared Nothing](#성능을-추구하기-위한-다중화-shared-nothing)
    * [Shared Disk와 Shared Nothing](#shared-disk와-shared-nothing)
* [적합한 아키텍처를 설계하기 위해](#적합한-아키텍처를-설계하기-위해)
    * [아키텍처의 정리](#아키텍처의-정리)


&nbsp;
## 아키텍처란
### 아키텍처 설계의 필요성
'아키텍처'란 '시스템을 만들기 위한 물리 레벨의 조합'이란 의미로 구체적으로는 '어떤 기능을 가진 서버를 준비하고 어떠한 저장소나 네트워크 기기와 조합해서 시스템 전체를 만들 것인가' 즉 하드웨어와 미들웨어의 구성을 가리킨다.


이 구성을 시스템이 완수해야 할 목적과 비교하면서 결정해 가는 것, 이것이 '아키텍처 설계'이다. 시스템의 '뼈대'를 생각하는 상위 설계란 함축적 의의가 아키텍처 설계에 있다.


아키텍처는 '그 시스템의 목적과 기능'을 표현하는 의미도 내포한다.


&nbsp;
### 아키텍처 설계의 중요성
'시스템에 요구되는 조건을 충족하기 위해 어떤 아키텍처가 적당할까'란 것을 생각하지 않고(데이터베이스 포함) 시스템 구축에 걸리는 비용을 산출하는 것은 불가능하다. 이런 의미에서 이 아키텍처나 설계란 것은 시스템 개발의 초반에 시행하는 일 중에서도 매우 중요한 일이다. 아키텍처는 시스템 개발 후반이 되면 변경하기가 어려우므로 프로젝트의 성패는 초반에 결정되는 것이 일반적이다.


&nbsp;
## 데이터베이스의 아키텍처 1. 역사와 개요
### 아키텍처의 역사
데이터베이스에 관한 아키텍처의 역사는 구체적으로 다음 3단계로 나누어서 파악할 수 있다:
1. Stand-alone(~1980년대)
2. 클라이언트/서버(1990년대~2000년)
3. Web 3계층(2000년~현재)


1단계 'Stand-alone'은 데이터베이스만으로 시스템이 성립하는 가장 간단한 방법이다. 2단계 '클라이언트/서버'는 클라이언트와 서버로 계층을 분리하여 상호 간에 네트워크로 접속한다. 3단계 'Web 3계층'은 현재 주류로 사용되며, 클라이언트/서버를 더욱더 발전시킨 것이다.


&nbsp;
### Stand-alone의 특징
Stand-alone은 문자 그대로 데이터베이스가 동작하는 머신('데이터베이스 서버' 또는 'DB 서버')이 LAN이나 인터넷 등의 네트워크에 접속하지 않고 '독립되어' 동작하는 구성이다.


이 구성에서는 데이터베이스의 미들웨어(DBMS)와 애플리케이션의 소프트웨어는 같은 DB 서버에서 동작한다. 따라서 데이터베이스를 사용하고 싶은 사용자는 DB 서버가 설치된 장소까지 물리적으로 접근하여 서버 앞에 앉아서 데이터베이스를 사용하지 않으면 안 된다. 서버가 네트워크에 접속되어 있지 않아서 물리적으로 떨어진 장소에서 액세스하는 것도 불가능하다.


&nbsp;
### Stand-alone의 단점
1. 물리적으로 떨어진 장소에서 접근할 수 없다.
네트워크에 연결되어 있지 않다는 것은 데이터 베이스를 이용하려면 데이터베이스 서버 앞에까지 가서 이용하는 방법밖에 없다는 의미이다.


2. 복수의 사용자가 동시에 작업할 수 없다.
네트워크에 연결되어 있지 않다는 것은 동시에 서버를 이용할 수 있는 사람 수가 1명으로 한정된다는 것이다.


3. 가용성이 낮다
서버가 1대밖에 없으므로 이 1대에 장애가 발생하면 서비스가 정지한다는 것도 큰 단점이다. 시스템이 서비스 제공시간에 장애 없이 서비스를 계속 지속할 수 있는 비율이 어느 정도인가를 나타내는 개념을 '가용성(Availability)'이라고 한다. Stand-alone 구성에서는 서버가 1대밖에 없어서 이 서버에 어떤 장애가 발생하면 그 시점부터 서비스는 정지하고 만다.


4. 확장성이 부족하다
Stand-alone은 성능 문제도 있다. 이것은 '성능이 나쁘다'는 것 이상으로 성능이 나쁠 때 '개선 수단'이 매우 부족하다는 것을 의미한다. 실제 머신이 1대밖에 없다는 것은 머신 그 자체의 성능을 올리는 것 이외에 개선 수단이 없다는 것을 의미한다. 이런 구성을 '확장성(Scalability)이 부족하다'고 표현한다. 게다가 교환하기 위해 시스템을 정지해야 해서 3의 가용성을 점점 낮추는 결과로 이어진다.


&nbsp;
### Stand-alone의 장점
Stand-alone의 장점은 구축이 매우 간단해서 소규모 작업이나 테스트를 빨리할 수 있다. 성능이나 가용성을 무시하면 노트북을 상요해서도 만들 수 있다.


그리고 보안이 매우 높다. 네트워크를 매개로 침입할 위험이 없기 때문에 사용자가 외부에 물리적으로(USB 메모리 등) 들고 가지 않는 한 서버가 바이러스에 감염되거나 공격받는 일은 일어나지 않는다. 데이터 유출 위험 또한 같은 이유로 매우 낮다.


하지만 이런 장점은 앞에 열거한 단점과 비교한다면 사소한 것이다.


&nbsp;
### 클라이언트/서버 특징
데이터베이스를 네트워크에 연결하면 복수 사용자가 물리적으로 떨어진 장소에서 데이터베이스에 접속할 수 있게 된다.


&nbsp;
![클라이언트/서버 구성]()


&nbsp;
데이터베이스 서버 1대에 복수 사용자의 단말이 접속하는 구성을 '클라이언트/서버' 구성 또는 줄여서 'C/S'나 '클라 서버'라고 한다. 또한, 이 구성은 시스템이 클라이언트와 서버의 2개 레이어(계층)로 구성되기 때문에 '2계층 구성'이라고 부르는 경우도 있다. DB서버에서는 DBMS가 동작하고 클라이언트에서는 업무 애플리케이션이 동작하는 분업체제로 볼 수 있다.


> NOTE. 서버와 클라이언트의 구별
>
> 서버와 클라이언트는 기본적으로 역할(기능)에 따라 머신을 구별하기 위해 붙여진 이름이다. '클라이언트'란 엔드 사용자가 직접 조작해서 수행하고 싶은 처리 명령을 내보내는 머신이다. '서버'는 클라이언트로부터 받은 명령을 실행하여 업무 처리(비즈니스 로직)를 실행하기 위한 머신이다.


&nbsp;
### 클라이언트/서버의 확장
이 구성은 주로 기업이나 조직 내에 닫힌 네트워크(LAN)에서 이용되었다. 인터넷 등 외부 네트워크를 거쳐 데이터베이스 서버에 사용자가 접속하는 일은 없었다. 그 이유는 데이터베이스가 매우 중요한 정보를 많이 축적하고 있는 서버라서 외부로부터의 접속을 허가해버리면 보안상의 위험이 증가하기 때문이다.


그래도 클라이언트/서버 구성 때문에 복수 사용자가 동시에 어느 정도 물리적으로 떨어진 장소에서도 접속할 수 있게 되었다. 현재 아키텍처의 주류는 아니지만, 조직 내에서 제한된 용도의 시스템으로 이용되고 있다.


하지만 클라이언트/서버 구성도 인터넷 시대에는 결정적으로 부적합한 단점을 몇 가지 안고 있었다.


&nbsp;
### 클라이언트/서버 구성의 단점
인터넷을 통해 시스템을 이용하는 클라이언트/서버 구성은 문제점이 2가지 있다. 한 가지는 인터넷에서 직접 데이터베이스에 접속하는 것에 대한 보안 위험, 그리도 또 하나가 불특정 다수의 사용자가 사용하는 클라이언트에서의 애플리케이션 관리비용이 많이 드는 점이다.


&nbsp;
### 관리비용 문제란
인터넷을 사용한 시스템의 편리성은 웹 브라우저만 된다면 어떤 클라이언트 환경에서도 동작한다는 간편함이 있다.


클라이언트/서버 시대에는 개인이 이용하는 PC에 애플리케이션을 설치해 동작하게 했다(네이티브(Native) 애플리케이션). 사용자가 특정 기업이나 조직 구성원에 한정되어 있고 관리대상 PC도 적다면 문제는 없다. 그러나 인터넷을 통해 전 세계 불특정 다수의 사용자가 이용하는 애플리케이션은 각종 환경에 대응해 애플리케이션을 작성해야 하고 각각에 대해 버전 관리나 버그 수정 버전을 배포하는 데 비현실적인 비용이 필요하게 된다.


이 때문에 비즈니스 로직을 실행하는 애플리케이션을 서버에서 관리해 비용을 절감하자는 요구가 나왔고 이에 대응하기 위해 제시된 것이 'Web 3계층'이라는 구성이다.


Web 3계층은 시스템을 다음 3가지 계층의 조합으로 생각하는 모델이다:
* 웹 서버 계층
* 애플리케이션 계층
* 데이터베이스 계층


&nbsp;
![Web 3계층]()


&nbsp;
### 웹 서버 계층과 애플리케이션 계층
Web 3계층 구성이 클라이언트와 데이터베이스 계층 사이에 '웹 서버 계층'과 '애플리케이션 계층'이 추가되어 있다.


웹 서버는 클라이언트로부터 접속 요청(HTTP 요청)을 직접 받아서 그 처리를 뒷단의 애플리케이션 계층(애플리케이션 서버)에 넘기고 그 결과를 클라이언트에 반환한다. 애플리케이션 서버와 클라이언트 웹 브라우저와의 가교 역할이다. (ex. 아파치, IIS 등)


애플리케이션 계층은 비즈니스 로직을 구현한 애플리케이션이 동작하는 층이다. 웹 서버로부터 연계된 요청을 처리하고, 필요하면 데이터베이스 계층(DB 서버)에 접속해서 데이터를 추출하고 이를 가공한 결과를 웹 서버로 반환한다. (ex. 톰캣, 웹로직, 웹스피어 등)


사용자로부터 직접적인 접속 요청을 받는 역할을 웹 서버 계층에 한정하여 애플리케이션 계층과 데이터베이스 계층의 보안을 높일 수 있다. 동시에 애플리케이션 계층에 비즈니스 로직을 집중해서 애플리케이션 관리 비용을 낮추는 구성이 될 수 있다.


이 구성은 현재 웹 시스템에서는 거의 표준이 되었다.


&nbsp;
## 데이터베이스의 아키텍처 2. 가용성과 확장성의 확보
### 가용성과 확장성을 확보하기 위해
Web 3계층의 장점으로 Stand-alone 구성의 단점 중 2가지 문제(1. 물리적으로 떨어진 장소에서 접근할 수 없다. 2. 복수 사용자가 동시에 작업할 수 없다.)는 해결했지만 3. 가용성이 낮고(서버가 1대밖에 없기 때문에 장애가 일어나면 서비스가 정지한다.) 4. 확장성이 부족하다(서버가 1대밖에 없기 때문에 해당 서버의 성능이 한계에 달하는 경우 서버를 상위 기종으로 교환하거나 고성능 부품으로 교환하는 것 외에는 성능을 개선할 방법이 없다.)는 문제가 남아있다.


각각에 대한 해결책을 생각해 보자.


&nbsp;
### 가용성을 높이는 2가지 전략
아키텍처 설계에서 견고한 시스템을 만들기 위해 가장 중요한 점이 가용성이다.


가용성을 높이려고 생각할 때 취할 수 있는 접근 방법은 크게 2가지가 있다:
* **고품질-소수 전략**: 시스템을 구성하는 각 컴포넌트의 신뢰성을 높여 장애 발생률을 낮게 억제해서 가용성을 높인다(소수정예 노선).
* **저품질-다수 전략**: 시스템을 구성하는 각 컴포넌트의 신뢰성을 계속해서 높이기보다는 '사물은 언젠가 망가진다'란 체념을 전제로 여분을 준비해 둔다. 이를 철저히 대비하는 것을 '물량작전'이라고 부른다.


과거에는 두 가지 전략 중 어느 한쪽이 더 효율적인가를 확실히 알지 못했기 때문에 양쪽 노선 모두를 추구했다. 하지만 현재는 거의 '저품질-다수 전략' 노선에 손을 들고 있다. 부품 한 개 한개의 신뢰성을 올리는 것보다 저품질이라도 수로 보완한다는 일종의 물량작전이다.


&nbsp;
### 클러스터란
동일한 기능의 컴포넌트를 병렬화하는 것을 '클러스터링(Clustering)'이라고 부른다. '동일한 기능의 컴포넌트를 복수 개 준비해 한 개의 기능을 실현한다'는 의미이다.


클러스터 구성으로 시스템의 가동률을 높이는 것을 '여유도(Redundancy)를 확보한다' 또는 '다중화'라고 지칭한다. 다중화는 시스템 세계에서 '내구성이 더 높고 견고하다'는 좋은 의미가 있다. 같은 기능을 가진 서버를 늘리면 늘릴수록 시스템 전체에서 장애 발생률이 낮아지기 때문에 이 점에서 컴포넌트 수가 많은 것이 맞는 것처럼 보인다. 예를 들어, 어떤 서버의 고장률이 10%라고 한다면 이 서버를 늘려갈 때 시스템 전체의 장애 발생률은 전 서버가 동시에 고장난 경우에 한해서만 일어나므로 서버가 증가할수록 다음과 같은 장애 발생률이 줄어들게 된다.
* 서버 1대 10%(0.1)
* 서버 2대 1%(0.1 x 0.1)
* 서버 3대 0.1%(0.1 x 0.1 x 0.1)


이것은 '적어도 1대가 동작하고 있다면 서비스를 계속할 수 있다고 간주한다'라는 로직에 기반을 둔 계산식이다. 이 장애 발생률을 100%에서 뺀다면 역으로 시스템이 무고장으로 동작할 확률, 즉 '가동률'이 나온다. 이것을 그래프로 나타내면 다음과 같은 곡선을 그린다:


&nbsp;
![시스템 가동률]()


&nbsp;
이 그래프에서 알아낼 수 있는 것은 2가지가 있다. 첫 번째로 가동률 100%는 원리적으로 불가능하다. 한없이 100%에 근접해 가지만 완전하게 100%가 되지는 않는다. 이것은 모든 서버나 네트워크 기기가 동시다발로 고장 나는 엄청난 우연의 가능성을 완전히 배제할 수 없기 때문이다.


두 번째는 서버 대수가 증가하면 증가할수록 1대를 추가함에 따라 얻을 수 있는 가동률의 향상 폭이 작아진다는 점이다. 1대에서 2대로 증가할 때는 가동률이 90%에서 99%로 9% 올라간다. 이에 비해 2대에서 3대로 증가할 때는 99%에서 99.9%가 되어 가동률 증가가 0.9%로 준다. 이건 결국 돈을 쓰면 쓸수록 1대분에서 얻을 수 있는 효과가 준다는 것을 의미한다.


&nbsp;
### 단일 장애점이란
다중화되어 있지 않아서 시스템 전체 서비스의 계속성에 영향을 주는 컴포넌트를 '단일 장애점(SPOF, Single Point of Failure)'라고 한다. 단일 장애점의 신뢰성이 시스템 전체의 가용성을 결정한다.


단일 장애점을 없애기 위해 대부분 이중화는(가장 비용이 많이 드는) 해두지만, 그 이상 어느 정도 돈을 들여 다중화할지는 예산 제약과 바라는 신뢰성 수준의 저울질에 달려 있다. 때때로 장애 발생률 0%를 달성하고 싶다는 욕구가 들지만, 이건 비용을 들여도 달성할 수 없는 '무한원점'과도 같은 목표이다.


> NOTE. 신뢰성과 가용성
>
> 신뢰성은 '하드웨어나 소프트웨어가 고장 나는 빈도(고장률)나 고장 기간을 나타내는 개념이고, 가용성은 '사용자 입장에서 볼 때 시스템을 어느 정도 사용할 수 있는지'를 나타낸다. 시스템을 구성하는 컴포넌트에 대해 적용하는 것이 신뢰성, 시스템 전체에서 사용자 눈높이에 맞춰 생각하는 경우가 가용성이라고 생각하면 된다. 신뢰성이 낮은 하드웨어나 소프트웨어를 사용하고 있다 하더라도 다중화(클러스터링)한다면 시스템 전체의 가용성을 높일 수 있다.
>
> 일반적으로 신뢰성이 99%라고 하면 매우 신뢰할 만하다고 생각하지만 시스템 세계에서 가용성 99%는 1%의 시간은 이용 불가능한 상황이 된다는 의미이고 1년중 3일 15시간 36분은 서비스 다운이 일어날 수 있음을 의미하고, 이는 가용성이 상당히 낮다고 본다.


&nbsp;
## DB 서버의 다중화 - 클러스터링
### DB 서버의 다중화
DB 서버는 다중화에서 특유의 어려운 문제점을 안고 있다. 그 때문에 DB 서버는 오랫동안 클러스터링이 어려운 컴포넌트로 인식됐다. 현재도 다양한 노력으로 방법이 고안되고 있지만, 간단히 병렬화해서 대수를 증가시키는 웹 서버나 애플리케이션 서버와 비교하면 다중화에 대해 고민해야 할 부분이 많다. 그 이유는 DB 서버가 데이터를 보존하는 '영속(Persistence 계층)'이기 때문이다.


&nbsp;
### DB와 다른 서버의 차이
데이터베이스는 데이터를 장기간 보존하는 매체가 필요하다. 이것이 기본적으로 데이터를 일시적으로 처리할 뿐인 웹서버나 애플리케이션 서버와 다른 점이다. 웹 서버나 애플리케이션 서버는 한창 처리 중일 때는 일시적으로 데이터를 보존하기도 하지만, 처리가 끝난 후까지 계속 데이터를 보존할 필요는 없다. 그래서 데이터를 유지하는 매체의 신뢰성이나 다중화에 그다지 신경 쓸 필요가 없다.


하지만 데이터베이스는 대량의 데이터를 영구적으로 보존해야 하고 그에 따른 성능도 요구되기 때문에 데이터를 보존하는 매체에 필요한 요건이 높다. 일반적으로는 서버 내부의 로컬 저장소나 메모리로는 이런 요건을 충족시키지 못하기 때문에 전용의 외부 저장소를 사용한다. 결국, DB 서버의 아키텍처는 저장소와 묶어서 생각해야 한다.


&nbsp;
![데이터베이스는 서버와 저장소로 구성된다]()


&nbsp;
이건 얼핏 보면 아무 문제도 없어 보이지만 DB 서버는 영속 계층의 사명이 부여되어 다중화 문제를 결정적으로 어렵게 하고 있다. CPU나 메모리 같은 처리에 필요한 컴포넌트를 다중화하는 것은 간단하지만, 데이터를 다중화하려고 한다면 매우 귀찮아진다. 데이터는 항상 갱신되기 때문에 다중화를 유지하는 중에 '데이터 정합성'도 중요하게 의식해야 하기 때문이다.


&nbsp;
### 가장 기본적인 다중화
가장 간단한 다중화 구성은 DB 서버만을 다중화하고 저장소는 하나만 두는 구성이다. 이 경우 데이터가 보존되는 저장소가 1개라서 정합성을 신경 쓸 필요가 없다. 이 구조는 데이터베이스가 저장소를 제대로 관리하고 있다.


&nbsp;
![DB 서버 다중화의 기본 구성]()


&nbsp;
위 그림에서 DB 서버가 2대 있지만, 이 2대가 동시에 동작하는 것을 허락할지에 따라 'Active-Active'와 'Active-Standby'로 나뉜다.
* **Active-Active**: 클러스터를 구성하는 컴포넌트를 동시에 가동한다.
* **Active-Standby**: 클러스터를 구성하는 컴포넌트 중 실제 가동하는 것은 Active, 남은 것은 대기(Standby)하고 있는다.


저장소를 공유한 Active-Active 구성이 가능한 DBMS는 현재 Oracle의 'RAC', DB2의 'pureScale' 뿐이다. 다른 DBMS에서는 Active-Standby 클러스터링만 대응하고 있다.


&nbsp;
### Active-Active 구성의 장점
Active-Active 구성은 2가지 장점이 있는데, 한 가지는 시스템 다운 시간이 짧다는 점이다. 복수의 DB 서버가 동시에 동작하고 있어서 한 대가 다운되어 동작 불능이되도 남은 서버가 처리를 계속해 시스템 전체가 정지하는 것을 방지할 수 있다. 이것은 웹 서버나 애플리케이션 서버의 클러스터링으로 얻을 수 있는 장점과 같다.


두 번째 장점은 성능이 좋다는 것이다. DB 서버 대수가 증가하면 동시에 가동하는 CPU나 메모리도 증가하기 때문에 성능도 향상될 수 있다. 단, 저장소가 병목(버틀넥)이 되기 때문에 생각한 만큼 성능이 향상되지 않는 경우도 있다.


&nbsp;
![Active-Active 구성의 장점과 과제]()


&nbsp;
Active-Standby 구성에서는 보통 Standby 상태의 DB 서버는 사용되지 않다가 Active DB 서버에서 장애가 일어날 때만 사용된다. 이 때문에 전환될 때까지 시차(보통 수십 초에서 수분)가 생기고 그사이 시스템은 서비스를 계속하는 것이 불가능한 상태, 즉 다운 상태가 된다.


&nbsp;
![Active-Standby 구성에서 장애를 검사하고 알아내는 과정]


&nbsp;
> NOTE. Hearbeat
>
> Active-Standby 구성에서 장애가 일어났을 때 Standby DB 서버는 어떻게 Active DB 서버에 장애가 일어난 것을 알아낼까? Standby DB 서버는 일정 간격(보통은 수 초에서 수십 초)으로 Active DB에 이상이 없는지를 조사하기 위한 통신을 하고 있다. 이 통신을 'Heartbeat'라고 한다. Active DB에 장애가 발생하면 이 신호가 끊기기 때문에 Standby 측은 Active가 '죽었다'는 것을 알게 된다.


&nbsp;
### Active-Standby 구성의 종류
Active-Standby 구성은 다시 'Cold-Standby'와 'Hot-Standby'로 구분된다.
* **Cold-Standby**: 평소에는 Standby DB가 작동하지 않다가 Active DB가 다운된 시점에 작동하는 구성이다.
* **Hot-Standby**: 평소에도 Standby DB가 작동하는 구성이다.


Hot-Standby 쪽이 전환시간은 짧지만, 그만큼 라이선스료가 높게 설정되어 있다. 항상 2대의 DB 서버를 사용하지만, 실제로 작동하는 것은 Active DB 1대뿐이기 때문에 전환 시간을 줄이기 위해 라이선스료를 많이 지급한다는 점에서 Hot-Standby는 매우 사치스러운 구성이라고 할 수 있다.


각 구성을 가용성과 성능이 좋은 순으로 정리하면 다음과 같다. 이 순서는 라이선스료의 '가격순'이다.
1. Active-Active
2. Active-Standby(Hot-Standby)
3. Active-Standby(Cold-Standby)


&nbsp;
## DB 서버와 데이터의 다중화 - 리플리케이션
### 리플리케이션이란
Active-Active와 Active-Standby 클러스터 구성에서는 서버 부분은 다중화할 수 있어도 저장소 부분은 다중화할 수 없어서 데이터를 다중화하지 않는 공통적인 단점이 있다. 즉, 저장소가 부서질 경우에는 데이터를 잃게 된다.


저장소도 보통은 내부 컴포넌트가 다중화되어 있지만, 데이터 센터 전체가 지진으로 붕괴하거나 화재가 난다면 끝이다. 이런 상황 대응하기 위한 클러스터 구성이 '리플리케이션(Replication)'이다. 이는 DB 서버와 저장소 세트를 복수로 준비하는 것을 말한다.


&nbsp;
![리플리케이션은 데이터를 복제한다]()


&nbsp;
> NOTE. 디스크를 다중화하는 RAID
> 
> 저장소 내부의 컴포넌트(대부분 하드디스크)를 다중화하는 기술을 'RAID(Redundant Array of Independent Disks)'라고 한다. RAID에는 몇 가지 종류가 있는데, 기본적으로 클러스터링과 동일하게 단일 장애점을 없애는 것이다. 즉, 디스크를 병렬로 나열해 디스크 한 개가 망가져도 데이터를 소실하지 않게 하는 것이다.


> NOTE. 리플리케이션 기술
>
> 리플레케이션 기술은 Oracle의 'Data Guard', DB2의 'HADR'란 이름의 상품이 있다.


리플리케이션은 데이터베이스 서버와 저장소가 동시에 사용 불능일 때, 서비스를 계속하는 것이 가능하다는 점에서 매우 가용성이 높은 아키텍처라고 할 수 있다.


&nbsp;
### 리플리케이션에서 주의할 점
리플리케이션에서 중요한 점은 Active 측 저장소의 데이터는 항상 사용자로부터 갱신된다는 것이다. 이 때문에 Standby 측 데이터에도 갱신을 반영하여 최신화하지 않으면(동기화) Active 측과의 데이터 정합성을 유지할 수 없다. 쉽게 말하면 Standby 측의 데이터가 점점 과거의 것이 된다는 뜻이다.


리플리케이션에서는 Active측 DB 서버에서 갱신된 데이터를 일정 주기로 Standby 측 DB 서버에 써 내려 간다. 이때 Standby 측의 갱신 주기를 얼마로 할 것인가와 성능 사이에 트레이드오프 관계가 생긴다. Standby 측 DB 서버에서도 기록이 성공한 것을 확인한 단계에서 Active 측의 갱신도 완료된 것으로 하는 것이 데이터 보호의 관점에서 바람직하지만, 이 확인 처리를 어느 정도 생략하면 성능을 향상할 수 있기 때문이다.


리플리케이션 구성은 원칙적으로는 차례로 손자나 증손자 세트를 만들 수 있다. 그 형태를 따라 이런 구성을 '피라미드형'이라고 부른다. 피라미드형 리플리케이션은 '데이터가 오래되도 참조만 하면 된다'는 처리를 손자나 증손자 세트에 하기 때문에 편리하다. 이를 통해 부모에 걸리는 부하를 분산할 수 있다.


다만, 그만큼 DB 서버의 라이선스료와 서버, 저장소의 비용이 들고, 시스템을 구성하는 노력도 증가한다.


&nbsp;
![피라미드형의 리플리케이션 구성]()


&nbsp;
> NOTE. 마스터 슬레이브 방식
>
> MySQL에서는 동기화하는 측의 부모(Active) 데이터베이스를 '마스터', 동기화되는 측의 자식(Standby) 데이터베이스를 '슬레이브'라고 부른다. 이 마스터와 슬레이브에 따른 리플리케이션을 '마스터 슬레이브 방식'이락 ㅗ부른다.


&nbsp;
## 성능을 추구하기 위한 다중화 - Shared Nothing
### Shared Disk와 Shared Nothing
앞서 Active-Active 구성의 DB는 저장소 부분이 병목되는 경우 있다고 했다. 이것은 복수의 서버가 1대의 디스크(저장소)를 공유하도록 구성되었기 때문에 일어나는 문제이다. 이렇게 복수의 서버가 1대의 디스크를 사용하는 구성을 'Shared Disk'라고 부른다.


Shared Disk 타입의 Active-Active 구성은 DB 서버를 늘려도 무한으로 처리율(단위 시간당 처리능력)이 향상되지 않고 어딘가에서 한계점에 도달한다. 이것은 저장소가 공유 자원이라서 쉽게 늘리기 어렵고 DB 서버 대수가 증가할수록 DB 서버 간의 정보공유를 위한 오버헤드가 크기 때문이다. 이 단점을 극복하기 이ㅜ한 아키텍처로 고안된 것이 'Shared Nothing'이다.


Shared Nothing은 문자 그대로 '아무것도 공유하지 않는다'란 의미로 네트워크 이외의 자원을 모두 분리하는(아무것도 공유하지 않는) 방식이다. 이 아키텍처는 서버와 저장소의 세트를 늘리면 병렬처리 때문에 선형적으로 성능이 향상되는 장점이 있다. Shared Disk와 Shared Nothing을 비교하면 다음과 같다:


&nbsp;
![Shared Disk와 Shared Nothing의 구성 비교]()


&nbsp;
Shared Nothing에서는 DB 서버와 저장소의 세트를 늘려서 저장소가 병목이 되는 것을 방지하고 있어서 이 세트에 비례해서 처리율이 증가한다는 이점을 얻을 수 있다.


&nbsp;
![Shared Disk와 Shared Nothing의 성능 비교]()


&nbsp;
Shared Nothing 방식은 비용 대비 성능이 좋다. Shared Disk 방식은 복잡한 동기화 구조가 필요해서 구축하려면 복잡하지만, Shared Nothing 방식은 같은 구성의 DB 서버를 횡으로 나열하기 때문에 구조가 간단하며 원칙적으로 DB 서버 수에 비례해서 저장소가 늘어난다.


Shared Nothing의 단점은 저장소를 공유하지 않아 결국 '각각의 DB 서버가 동일한 1개의 데이터에 액세스할 수 없다'는 것이다. 이런 문제에 대처하려면 DB 서버 하나가 다운되었을 때 다른 DB 서버가 이를 이어받아 계속 처리할 수 있게 하는 '커버링(Covering)' 구성 등을 고려해야 한다. 이런 문제의 대책까지 처음부터 고려해야 하는 것을 보면 아이디어는 간단해 보이지만 Shared Nothing도 보기보다 복잡한 구조임을 알 수 있다.


&nbsp;
## 적합한 아키텍처를 설계하기 위해
### 아키텍처의 정리
아키텍처의 선택은 시스템이 충족해야 하는 요건에 따라 결정되기 때문에 요건을 결정하지 않으면 아키텍처도 결정할 수 없다. 가용성, 신뢰성, 재해대책, 성능, 보안 같은 기능적이지 않은 요건에 대해서도 어느 정도 수준으로 요구할 것인지에 따라 선택해야 할 아키텍처 구조가 바뀌게 된다.


데이터베이스의 아키텍처 패턴을 트리형식으로 정리하면 다음과 같다:


&nbsp;
![데이터베이스의 아키텍처 패턴]()


&nbsp;
&nbsp;      
### [by. 0junChoi](https://github.com/0jun0815) email: <0jun0815@gmail.com>
### 출처: [데이터베이스 첫걸음](http://book.naver.com/bookdb/book_detail.nhn?bid=11154846)

