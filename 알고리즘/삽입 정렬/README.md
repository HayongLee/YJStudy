# 삽입 정렬 


* [개요](#개요)
* [구현](#구현)


&nbsp;
## 개요
* 평균 런타임은 O(n²)으로, 대규모 데이터 세트를 처리하기에는 매우 비효율적이다.
* 대상 데이터가 이미 어느정도 정렬돼 있는 경우, 혹은 규모가 크지 않은 경우 유용, 이런 경우엔 O(nlogn)인 병합 정렬보다도 높은 성능
* 삽입 정렬 알고리즘은 인플레이스 정렬(in-place sorting) 방식을 사용한다.
* N-1회 반복, 처음 정렬 순서를 정할 때 0번째 요소의 순서가 이미 정해졌음을 감안해서 i-1로 시작한다.


![](https://github.com/0jun0815/YJStudy/blob/master/알고리즘/삽입%20정렬/images/insertion-sort.jpg)


### 삽입 정렬 알고리즘 활용 사례
* 요소들 대부분이 정렬된 상태이거나 순서를 약간씩만 바꿔도 될 때 활용할 수 있는 방법이다.
* 카드 게임: 카드 목록의 재정렬 작업에 효율적
* 2D 게임 디자인에서 y축으로 길게 늘어선 스프라이트 이미지 목록의 정렬: 삽입 정렬을 통해 다양한 이미지 요소를 반복 순회하며 목록에서 가져온 뒤 인접 요소와 교체함으로써 사람이 도시를 걷거나 자동차가 도로를 질주하는 장면을 연출


&nbsp;
## 구현
### 삽입 정렬 알고리즘
```
public func insertionSort<T: Comparable>(_ list: inout [T]) {
    // 요소가 하나뿐이면 종료한다.
    if list.count <= 1 {
        return
    }
    // i = 1 요소부터 list.count - 1까지 반복 순회한다.
    for i in 1 ..< list.count {
    // 인덱스 i의 요소는 최종 정렬 장소에 삽입할 수 있도록 x에 저장한다.
        let x = list[i]
        var j = i
        // 내부 루프에서 높은 순으로 정렬을 시작한다.
        // list[j - 1]의 요소가 x보다 크면 우측으로 이동한다.
        while j > 0 && list[j - 1] > x {
            list[j] = list[j - 1]
            j -= 1
        }
        // list[j - 1] 요소가 x보다 작거나 j = 0인 경우, x를 넣을 장소를 찾은 것이다.
        list[j] = x
    }
    // 이 과정을 목록에 있는 요소 N만큼 반복 수행한다.
}
```


### 최적화
* 삽입 정렬은 이차(quadratic) 알고리즘이므로, 대규모 데이터 세트를 만났을 때 이를 최적화 할 수 있는 방법이 별로 없다. 따라서 대규모 세트를 처리해야 한다면 병합 정렬 또는 신속 정렬과 같은 알고리즘을 활용하는 편이 낫다.


&nbsp;
&nbsp;      
### [by. 0junChoi](https://github.com/0jun0815) email: <0jun0815@gamil.com>
### 출처: [스위프트 데이터 구조와 알고리즘](http://acornpub.co.kr/book/swift-structure-algorithms)
